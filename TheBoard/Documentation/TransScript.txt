What is Node.js?

Introduction

Welcome to the Node.js for .NET Developers course. My name is Shawn Wildermuth. In this first module, we're going to be talking about what is Node.js? This is going to include a discussion of Node.js in a nutshell, why Node.js is important, we're going to look at installing Node.js, doing some Hello World in Node.js so you can see some of the basics of how it works, we're going to use Node.js with Visual Studio, and we're going to talk about dependency management, then the Node Package Manager. Let's get started.

What is Node.js

So, if you're watching this course, you're likely a .NET developer. This means you've been using one of a variety of Microsoft technologies, probably to already build websites. You may have been doing ASP.net web forms, ASP.net MVC, maybe ASP.net web API. You may be using WPF. You might be also using desktop technologies like WPF or WinForms. So, if you're watching this course, you're probably interested in what Node can do for you and how to map the concepts you may or may not already have access to using Node. And I'm going to try to, in this course, give you that brief introduction to explain what Node is and then we're going to walk through and build a Node application from scratch. Along the way, I'll discuss how .NET and Node.js are different or are even complimentary. So, what is Node.js? You can see here that the official definition is about creating a non-blocking I/O event-driven model or fast, scalable network applications. But, what we're really talking about is being able to write server-side code with the same sort of templating engines, business logic, data access that you would build in ASP.net and its associated technologies like the BPF and web API and MVC. So, at its heart, we can think of Node.js as being a different kind of server and in many ways a much simpler server than using something like IIS. ASP.net is certainly headed in that direction with some of the OWIN and Katana deliverables they're talking about, but Node.js is kind of in there already. When we talk about Node.js, we're talking about server-side JavaScript. Out-of-the-box, the default behavior for this JavaScript is for it to be modular JavaScript as the notions of dependency and package management out-of-the-box and it's the default behavior in the way that Node.js works. The way you write JavaScript on the server is it encourages non-blocking or asynchronous code. This is one of the big differences between ASP.net and Node in that you can create asynchronous code in ASP.net, but it isn't the default or basic behavior. In many ways, by learning Node.js, you can learn better ways of writing server-side code and apply those to existing ASP.net applications that you're already using. In the case of Node.js, HTTP, networking, and WebSockets are already first class citizens, so they're built into the box in order to create faster, scalable web applications. Node.js tries to treat asynchronous networking calls and new technologies like WebSockets as things you should be comfortable using. Therefore, they are available out-of-the-box. So, you should think about Node.js as being a low-level, but fast platform. It allows fast execution of the code that you're going to write on the server and it is low-level. But, Node.js itself isn't JavaScript. It's a platform for executing JavaScript. So, when I hear people talk about ASP.net being better because it's compiled and, of course, JavaScript can't be as fast, of course Node should be slower than this same sort of behavior in ASP.net. And, in fact, they're pretty similar because most of the core code that you're going to be dealing with is actually native code. JavaScript is just the framework around which you write your piece of code. Let's take a look at how Node.js and traditional web servers like IIS and ASP.net are different. A traditional web server is more like an ATM. You've got requests coming in and usually as a request is being fulfilled, the person at the front of the line is using that ATM. And, the code you tend to write is this synchronous interaction with whatever the code is. I'm going to the database to get some data, I'm doing some calculations, I'm rendering some screens. All this is synchronous so that you're using a thread to serve an individual request until you're done. So, the goal has always been to be really efficient in the use of that thread. Because it's synchronous, we know that we're going to take the thread out of a pool of threads in ASP.net while we're processing this request. If too many people are lined up to get at the different ATM ports that are out there, you can think of this as that thread pool, then other operations simply wait. So, like the ATM, these tend to stack up. In Node, it's more like a coffee shop. People can come in and make requests, but they are started when the request is made. Some part of the operation, maybe some business logic is executed, but then for most of the operations, it's going to use asynchronous callbacks. Therefore, you have these other people waiting for requests to be fulfilled until you're not consuming a whole thread the entire time the request is made. During these spots where we're using non-blocking I/O, whether we're going to a database or opening up a file or whatever it may be, we're freeing up that thread for other requests to be handled. This is the default behavior in Node.js and this is one of the reasons it has been able to achieve some high level of scalability. In ASP.net, you can accomplish the same things, but you have to think about it in those ways. You have to start by using asynchrony as a feature of your web applications. And, not many applications out there are actually doing this. In web forms, this is a little more difficult, but in MVC and web API, there's actually support for asychronicity in your controllers. There's just not a lot of websites out there that are taking advantage of that. Let's look at it in a different way. In a traditional web server, the client makes a request and then while that request is being fulfilled, we're consuming the server resource the entire time. The request is made and then a dedicated thread is used to service the request. And then when the operation is complete, it returns the response. In Node.js or the async of server model, a request is made and that thread is being used while it needs to be actually doing work. When it goes to do some asynchronous work, when it's in a wait state because it's opening a file, making a network request, maybe getting data from a database, that thread is free to service other requests. Once the async operation is complete, the event is fired to say, "Hey, we've now got the back half of what needs to be done. Let's consume that thread for this amount of time and then return that response." And in this way, a single machine or a single set of servers can handle many more users because we're not consuming those threads and, therefore, running out of threads. So, soon I'll show you how Node.js actually works, the natural behavior of doing simple things like making requests to get a web page and rendering pages, and I want you to think about it from your .NET perspective and see how different this is. So, not only are you learning Node in this course, but hopefully you're learning how to better build web applications using .NET technologies. So, when you think about Node.js, remember that it is asynchronous by default, by nature. You can accomplish the same thing in ASP.net, but it's simply not the default behavior.

Comparing Node.js to .NET

So, if you're already using .NET technologies to build web applications, you already have some concepts that you're used to. And, I want to map the concepts that you have to the Node equivalents of them. First, is IIS. IIS maps to the Node.exe. This is the executable that hosts all of Node. We'll see how this works in our first demo coming up next. But, instead of having an OS level of service, we're really just having a simple executable that knows how to host JavaScript in order to service web requests. You can get some of the other behavior that you're used to from IIS in managing a lot of other things like handling certificates and redirection and all of that. But, Node is a much simpler version of this. Lighter, but also simpler. In .NET, if you're used to using C# or VB or even any of the other languages like F#, you're going to really map that to JavaScript. All your client code in Node.js unsurprisingly, I hope at this point, is going to be JavaScript. The nature of this JavaScript is a little different than you're used to writing on the client inside the browser, but it still is JavaScript. So, all the skills you have when writing in JavaScript you can apply on both sides of the wire. When you're looking at something like Entity Framework and SQL server, you're really going to map this to the concept of a database driver inside of Node. This is all often going to be MongoDB or some other data store. This includes databases like SQL server and Oracle. There are actually ways of getting at data from traditional databases as well. Going to Node.js doesn't mean you have to go to document databases or no SQL databases, but it is something that's pretty common. When you start to look at the literature, you're going to see that Node is often married with MongoDB or CouchDB or Raven or other document databases out there. When you look at ASP.net web forms, if you're coming from that world, we're going to show you how a web framework in Node.js called Express can be used with a markup language called EJS in order to take those same skills that you're used to. EJS is a way to template your views and so it uses a familiar syntax for those of you who are using web forms. If you're coming from the MVC or Razor camp, you can still use Express as that web framework, but you're going to use a different templating engine, either Jade or Razor, and we'll show you both. And, if you're comfortable with ASP.net web API, you're going to find that Express itself, the web framework we're going to introduce you to, is going to allow you to write much like you were already doing in ASP.net web API. If you're using a client-side library to do templating and data binding and module creation and navigation, whether you're using AngularJS, Ember, Knockout, Backbone, whatever it is, that's not going to change. Your server-side technologies are still going to be available here. There's nothing magic in the way that Node works. You're still serving up web pages, JavaScript, and CSS and then having that client-side script still do some of the heavy lifting to allow you to create great user experiences. If you're familiar with SignalR, you're going to see that WebSockets and a technology that wraps it called Socket.io are a way to get that same sort of rich connection behavior that you're used to in SignalR. So, we've talked a lot about JavaScript so far, but let's get into some of the meat and potatoes of the JavaScript in Node.js because it is a little different. In the case of JavaScript in Node.js, all the JavaScript is executed under Google's V8 engine, so it's a predictable execution model. This is very different from writing JavaScript in the browser because in the browser you have to deal with these different environments. What if I'm running in an old version of IE? What if I'm running in a browser on a mobile device? What if I'm running in Safari? Do I need to deal with shims and other things to deal with the different levels of JavaScript that are out there? Writing JavaScript in Node.js gets easier in that you know what that execution model is. There's one and only one engine you're going to have to deal with. It's fairly up-to-date and, in fact, supports things like ECMAScript 5 as long as you're using Node.js 0.5.1 or later. V8 also supports Just-In-Time compilation, as well as an optimizing compiler so that the JavaScript you're running should run really fast. Now, is this on par with .NET compiled code? In fact, it's pretty similar. And, the reason it's pretty similar is that effectively the JavaScript is compiled and cached much like .NET code is. Remember that when you compile a .NET assembly, you're not compiling machine code. You're compiling intermediate language. This intermediate language is much like what the JavaScript is. So, at some point, some piece of code needs to go out and as you execute your code, it's going to Just-In-Time compile them and then cache those machine language pieces for you. And, so the V8 engine inside of Node.js does the same thing that the CLR does for your ASP.net code. What this means is that lots of the problems that you have experienced as a JavaScript developer in the browser simply go away. Node.js has a very predictable execution engine and so you don't have to deal with, "Well, what if I'm using an older browser? What if I'm using a browser that doesn't compile? Or, what if I have differences between the different engines?" You know that your JavaScript is going to run inside of Node and, therefore, Node is this very predictable environment. You have complete control over this environment, which is not the case for when you're writing JavaScript in the browser. Enough theory. Let's start to look at what Node does and let you get comfortable with the way that Node actually will let you build web applications today.

Installing Node.js

So, let's start by getting Node.js installed on our machine. I'm starting with a clean machine where Node.js doesn't exist. All I'm going to do is open a web browser to Nodejs.org. This is kind of the home for understanding how Node works, getting the package to install it, as well as looking at the API docs. I'm going to go ahead and click Install and it's detected the machine I'm on, so it's going to download the latest version for x64. So, it's going to download the 64-bit version. It knows which machine I'm on because of the header information, but doesn't guess right or you want to know something different, you can go ahead and get the installers for Windows, for Mac, or actually get the source code itself. So for me, I'm going to go ahead and get the 64-bit version of the installer. Go ahead and save this and I'm just going to put this on my downloads. And, then I'm going to go ahead and just run the installer. So, the installer is pretty simple. It just has you set it up, accept the license agreement, and make sure and read all of this because we always read the license agreement, right? Yes, we do. Keep on telling yourself that. It can ask you where to install it. To make it a little easier, I often will change it to just some root directory. You can leave it in the Programs folder if you like. I just like knowing where it's at, so I'm going to go ahead and put it on my D drive. And then, here are the couple of pieces that are interesting. You're going to want to install Node, the runtime, and if this were going to go on a server, I might not bother with NPM or adding it to path or online documentation shortcuts, but in this case, I'm going to include them all. The add to path is important because it's going to make sure that when we open a console window, we'll be able to use Node. Now, it's been installed. So, if we open a console window, I'll just say Command, and I'll just head over to our folder where we want to use Node. We can see here by just typing Node, it's going to put us into a shell. And, this is just going to allow us to write JavaScript and execute it. So, let's say "var X = 1, X" and we'll get the result, which is 1. We got an undefined at the first because this var X = 1 doesn't actually return anything. We could say Hello World and that would return something. Return the string, that is, the result of that. And, we can even build the sorts of expressions that you're used to doing. So, we're probably never going to use this command line or ripple version of Node, but it's interesting to know that it's there. You can see because we put this in the path that the Node executable is now available everywhere. Go ahead and quit that. And, now let's dive into our first JavaScript file hosted in Node.

Hello World Node.js

So next, let's take a look at Node hosting its first JavaScript file. So, I'm here in a brand new folder. There's absolutely nothing in this folder right now. I'm going to go ahead and create a new file called test.js just so that we have a JavaScript file to start with. Let's do something simple like console.log Hello World. In the case of Node, console.log actually goes to the output window of Node so you can use this for some rudimentary debugging. We head back over to our console window. We can simply type "Node" and then the name of a JavaScript file to execute. And, in this case, that's going to be test.js. And you can see what it's done here is that it's executed the test.js and the log has shown up here in Hello World. Now, we're a bit far from actually developing a website with this. We can see that all Node really does is it's an execution engine for JavaScript files. To really make sure that we understand that this is JavaScript code, let's create a couple of variables here. And, again, use console.log to do something like x.name + put a space x.birthplace and see what happens. If we run the Node again, we're going to get both Hello Worlds: The one from the original console.log, as well as the one we put together using just some very simple JavaScript code. So, what's interesting here is it's simply a JavaScript engine. There's nothing magical about what it's doing. Of course, if you were expecting that Node was simply going to start posting a website and we were going to put files in a directory and it was going to know about all that, it's much simpler than that. And, we can use some frameworks and some built-in technologies inside of Node who host a simple website. All of that is built into Node and then there's some frameworks we can lay on top of them in order to build websites. But, out-of-the-box, Node really is just a wrapper around the V8 engine in order to execute code.

Node.js with Visual Studio

Of course, you're coming to Node from the perspective of a .NET developer, so you might be curious whether you can use Node.js in Visual Studio, whether you have to use those command line tools or other sorts of editors. Well, luckily you can use Visual Studio if that's already a comfortable environment for you. In this case, we can actually look in Visual Studio under Tools and Extensions and there's a special extension that I already have installed called the Node tools. It allows us to host Node applications, deal with the interactive window in Node, as well as profiling of Node code. This is an extension for Visual Studio. Therefore, this will not work with the free Web Express tools. You're going to have to have at least Visual Studio Professional to use Node in Visual Studio, but it is pretty simple. If you code to Nodejstools.codeplex.com, you'll see this early alpha version of an integration for Visual Studio. And, you can download it and install it. It's not going to be something that's going to be simply available through the extension manager. You'll want to download it here and install it, which I've already done. And, so that means when we create a new project, you will see installed in here under Other Languages and then JavaScript are going to be some new templates. You can create a project from existing Node.js code, a blank console applications, a blank web application, an Express application, and then some Azure, Node, and Express applications. We're going to start with a blank console application. This is going to create almost nothing for us, so we can kind of play around with Node. We're just going to call this the "Fun With Node" project. And so, what this has really done is create an app.js starting point that is going to be the beginning of your project and then two other files: A readme file for you to explain what the project is, pretty typical for GitHub projects, and also something called the Package JSON that we'll talk about in a few minutes. But, let's start with the experience from Visual Studio. Let's do something similar to what we did earlier. Let's create a couple variables and let's go ahead and log X times Y, which hopefully should be 250. And, because this is in Visual Studio, you're going to want to get that experience of actually setting break points. So at this point, we just hit F5 like we would in any Visual Studio project and it'll actually launch Node and allow you to walk through and debug code. Here we can look and see that X and Y are 10 and 25. We can add watch variables here for, let's say, X. We can even type in code in the immediate window in order to get the values of those. Look at call stacks, really anything. So, this is an integrated environment for building your Node applications. As of the recording of this course, it is an alpha, so there are some peculiarities still. But, it's surprisingly full-featured. There's lots of people writing Node applications using Visual Studio now because it tends to be this simple. What's interesting is if we open up the file explorer here, we can see that what it's created are the files, but then there's this simple NJS proj file and a solution file like you're probably used to doing with most sorts of projects, right? It's a solution file and then some sort of project file: A CS Proj, a VB Proj, whatever the case may be. But, what's also interesting is if we open up the command prompt here is we can execute Nodeapp.js and it's the same sort of behavior as we would expect. So, using Visual Studio, while it gives you some features, doesn't really take away any of the nature of the way you would write your application using Node. I find that I tend to drop down into Visual Studio for debugging, but I tend to use the lighter tools whether it's Sublime or WebStorm or even WebMatrix to write my Node application and then when I really need debugging, I might use Visual Studio because that's a very comfortable environment. I can debug in WebStorm as well, but I'm just not as comfortable there. And, so I find that using Visual Studio is plenty good.

Dependency Management

One of the core concepts you're going to want to use in Node is the way that dependency management is handled. From the very first application you write, you're going to be using this as dependency management. This isn't something that is bolted on like it tends to be in ASP.net. It's something that's part of the core Node.js experience. Let's see what this looks like. So, we could write our application using one JS file for everything, just have it thousands and thousands of lines of code. But, we really want to encourage you to write your JavaScript in a modular way. And, Node.js certainly makes that simple. The idea here is that as we need different pieces of modular code, Node doesn't go and look for every .js file in the folder, load it all at once, and hope that it all co-mingles together. It actually uses a facility for requiring certain behaviors. If you've used client-side libraries like RequireJS, this is going to be similar to that. This is actually based on an idea called CommonJS that should be coming to most of the web browsers in the future. ECMA-6 is probably going to adopt this for the way it does its own dependency management. So, to bring another JavaScript file in here, we're going to use the keyword "Require". And, in it we're going to give it a path. And, let's go ahead and give it a path to a file called message.js. And, Node is going to require you to tell it what directory it's in. We can use ./ to say that we expect this to be in the same directory. It doesn't actually work if you just give it a path without ./ in it, but it also could be ../ or ./foo for getting it out of a folder. For us, we'll just go ahead and require it as a new JavaScript file. When you require, it's going to return as object that's going to represent that modular piece of code, so we need to go ahead and assign it. It's not uncommon for the variable name to be the same as the modular name that you're thinking about. Let's go ahead and create that file. Now, in this system, each file has access to something called the module.exports. This is an endpoint that is often aliased as just exports. To an object it's a bag of properties that you can assign to. So, in our case, let's go ahead and say exports.first = "This is the first message". And, that's all we need to include in this JavaScript file. When this is brought in, this code is going to execute and add to the exports. The exports is the object that is returned from Require so that we can then access this member of the exports. So, here we can say console.log messages.first and, unsurprising, we do Nodeapp.js, we're going to get "This is the first message" written out to the console. So, this Require is executing the JavaScript, allowing it to construct an object that is returned to us that has some functionality. This could be a class constructor. This could be an object that has a number of elements in it. Or it might be, in this case, a simple object that's returned. There's different patterns for this. And we can export more than one thing or even export complex objects. When this is executed, this messages will now have all the properties we set here. Console. And if we run that, we'll see that we're getting the string messages, but we can also have it output the actual object that was being set. So, by marrying Require, as well as the module.exports, you can create these modular applications. So, this is an important concept. When we tell Node to launch app.js, that is the bootstrap or the starting point for the pieces of code that this application is going to need and it can cascade through. This messages could have its own set of requires. And inside of those JavaScript files, they could require their own as well. And so, you can walk down that list and figure out all the ones to load. The Require functionality loads it and loads it once. And, so that whatever code is execute here, this is never executed a second time. This exports first, second, and third as the messages and if someone else asks for this object by RequireJS, it's going to get a cached version of this. So, it really is like dependency management. Let's look at some other ways. Obviously, populating the exports first, second, and third with just properties works. But, you don't actually have to export these as properties. So, let's do something different. Let's say that what we're going to export is simply going to be function. And, this isn't uncommon where what this actually does is every time we get one, we can execute the result of the Require call in order to run code. And that means that this code is executed every time that it's called as a function. One problem here is that when we just assign exports as a function, JavaScript gets a little confused because it doesn't know what exports is at that point, so we have to prefix it with module.exports, which is really the full version of that. This has to do with how it's scoped. I tend to in these applications always use the full module.exports so there's never any confusion, so that if I change it from adding properties to adding something like a function to it that it doesn't get confused later. In here, let's go ahead and return just some message. And then, in our use of this, instead of calling a property, we can just execute it like a function because that's, in fact, what this object is. It ends up being a function that Require builds. So, if we run it, we're now getting "This is a message" and the difference here in what we did a minute ago is that every time we execute this, that code inside the function is re-executed. Remember, because this is just building up the code when it's parsed, this function is still an executable part of code. Another common pattern you're going to want to be aware of is using this as a constructor method. So, when exports is executed, we can treat it as a class. So, let's change this to this.first. And by using the "this", we're implying that this is a constructor method, so that over here when we get this messages, we can say create a new messages and then we can call the properties of that object. So this is, in essence, the same thing as when you're creating a pseudo class in JavaScript and allowing you to create instances of it and then, obviously, use properties of it. We go ahead and execute this. We can see that we're still getting the same behavior because we're asking for the messages.first. Now, using Require for individual files isn't uncommon, but there's another pattern you should be also aware of.

Folder Dependencies

Next, let's see how folder dependencies work. If we're back at this fun with Node project again, let's go ahead and create a new folder called Logger and create in it a file called index.js. And, that name index.js is important. This is going to use the same pattern because we're going to depend on it. We're going to load it with Require. Now, let's create a really simple member here that says log. And for now, we'll just do console.log with whatever that message is and let's pass in that message. Really simple Logger with the idea that we might make this more complex later. Inside the app.js, if we want to use this, we can use Require, but in this case, we're going to point it at a folder name. Now, what's interesting here is that earlier I showed you pulling in an individual file. Require doesn't care what the file name is actually. We could just have it as "Messages" and it would look for messages.js. It would also look for messages as a directory and whichever one it found first, lookmessages.js would find first, it would pull that in. If not, it would then look for a directory. If not, it would fail that it can't find that module. In our case, we could say logger/index.js and that would be perfectly valid. But, by just saying logger, since there isn't a logger.js, there's a logger directory, it's going to, by default, load the index.js as that starting point for our logger. Let's go ahead and use it. Logger.log, "This is from the logger". And, again, we'll execute it. This is from the logger, right? So, on its own, you might think, "Well, why bother going through this extra step of creating a folder and an index?" And, the reason for it is you may be putting together a complex dependency. This complex dependency may have other pieces it depends on. So, we might have a file.text and then we might actually use this. The person that needs the logger doesn't need to know that there's a bunch of these other dependencies like the file.logger here. This is a form of encapsulation so that as we're building more complex pieces, we can build them out of multiple files, though to the consumer of them, they might be just a single file. Now, this doesn't require a folder, it just implies that a folder is a good way to manage those sorts of dependencies. We're going to see this when we build out an actual working website how this works in practice.

Node Package Manager (NPM)

The last important piece of Node you're going to want to know about before we start building web applications with it is something called the Node Package Manager, or NPM for short. So, the Node Package Manager is a way we can install different pieces of functionality that aren't built into Node. We look at NPMJS.org, it's a website that contains all the modules that are available to NPM. You can see most depended on, most updated, most starred, et cetera. This is just the registry for what packages are available. Usually as you learn the different packages you're going to use, you're going to find that there are NPMs for them. One of the things that is pretty common in a lot of my applications, especially in the browser, is underscore, right? If we search for underscore, we can see that there's a version of underscore packaged as an NPM that we can bring directly into our project. So, let's do that by using the command NPM install and then the name of the package. In this case, that is underscore. We can see that it went out, looked for the package, and installed it. We can see here in our directory structure that it's created a new folder called Node_modules. And, this is where NPM will install these modules. And, here is our underscore module. This, in fact, contains a number of files: The underscore and underscore min that we're going to use and then the package itself. So, if we come over here into app, we can now say Require underscore. Notice I'm not using a path like I did here. It's just the name. These names are going to tell it, "Hey, this is a module that I'm depending on" and so that I can then say _.contains and then call standard pieces of reusable code. In this way, you can think of the Require as a sort of the way that you introduce script tags onto web pages. Now, it's not required that the name here match, in fact, for underscore itself, I usually actually make it an underscore. Again, remember because this is using Require, it's going out and taking whatever is the interface for that component, in this case underscore, and returning it using module exports. Therefore, I can just assign it to underscore and _.contains, which, if you used underscore before, is a pretty common pattern, is perfectly valid. What's interesting is that the Node modules are much like NuGet packages in .NET in that they're not really expected to be checked in to source control and those sorts of things, but then we have to know what Node modules we've actually used. And, that's where the idea of project dependencies comes in. This package.JSON file was one that was created by the template forest. This is a simple piece of JSON that describes our project: What version we're using, some description, what is the main script for our application, and then some information about me, the author. One of the things that it's not showing here is what modules I depend on. Node Package Manager has the notion of Require dependencies, optional dependencies, and development dependencies. Require dependencies are ones that it knows I need to run by default. Optional are ones that may make my operations a little better. And then development dependencies are dependencies that are useful while I'm working on the code. This is often modules that are only used by development tools, not your actual application. So, what we'd like to do is when we install a package, we'd like my application to know that it's dependent on it. So, if we come back here to NPM, let's go ahead and uninstall it real quick. Underscore. When we do that, you'll notice the Node modules was left here, but the whole directory for underscore is gone. But, if we go ahead and reinstall it, but we use a flag called Save, it's going to tell NPM that we want to save it into our package.JSON as a dependency. It reinstalled it, as we can see here, but it also added it as a dependency. Not only added it as a dependency, it told me what version we depended on. This is how you're going to manage the dependencies. What's interesting here is that this package.JSON dependencies chain actually goes down. So, if we look at underscore, it has its own package.JSON, which includes any dependencies it would have. There actually are none for underscore, so let's bring in another one. So, we go out here and we install a bigger, more complex project, let's say Express, which is a web framework we're going to be spending a lot of time with. Let's go ahead and give it a save as well to tell it that we want to install Express and save it as a dependency. It's going to get a bunch of different modules, all of its dependencies, and it's added itself here to our Node modules. This actually extends further down, so if we look at Express, we can see that it has its own package.JSON and that it has dependencies of its own that need to be fulfilled and they may have their own dependencies, as well as developer dependencies. But, the dependencies mean that when we go and install Express, it's going to look at all these and get all of these for us as well. So, it's going to walk down those dependency chains when it brings in those packages for us. Now that we have dependencies required here in the package.JSON, we shouldn't actually check in into source control the Node modules themselves. Much like NuGet in .NET. So, what would happen if we went ahead and just deleted this folder. Delete Node modules. So, our code isn't going to run because we don't have these dependencies. But, the package.JSON describes the dependencies. That means we can tell NPM to install all of the dependencies in package.JSON by saying NPM install. It's going to read our package.JSON and then go get all the dependencies that our project needs. And, then inside bin are going to be any commands that certain modules need as well. But, usually it's going to be one folder per dependency. So, I know we haven't built anything really webby yet, but I wanted you to understand how Node itself worked. How to loading in different packages, how including Node packages into your project work, as well as how the JavaScript engine in its simplest form works, the Node.exe's relationship to JavaScript. With that in mind, we can start to build web applications in the next module. But, let's wrap up this module first.

Summary

So, what is Node.js? The simplicity of Node.js belies the fact that it can be a powerful web server environment. One that allows you to utilize the JavaScript skills you have for writing client code to writing server-side code. If you already have a knowledge of JavaScript, you can get up to speed with how Node works fairly quickly. Because Node.js uses Google's V8 engine, the JavaScript execution environment is not only fast, but also modern. So, you're getting Just-In-Time compilation, you're getting on optimizing compiler, you're getting ECMA Script 5 if you're using a fairly recent version of Node. You're getting this predictable environment to run your JavaScript. We've see that installing Node.js is pretty simple and that if you want to stay in the comfortable confines of Visual Studio, you can certainly do that with the simple extension that allows you to run in more importantly debug Node applications. We've also learned that Node.js encourages some good practices right out-of-the-box. The ideas of dependency management packaging and versional control and even asynchrony are part of the mindset of Node. And, in building Node applications, you're going to find that this is going to pervade and help you build better code regardless of the server environment. This has been the first module of Node.js for .NET developers. My name is Shawn Wildermuth. Thanks.

Building a Web Site with Node.js

Introduction

In this module, we'll build a website with Node.js. We're going to start out by creating a brand new project, introducing Express as the web framework, I'll introduce you to the view engines, we'll talk about controllers, services, static resources, dealing with client-side dependencies, and finally some tricks to improving development speed. Let's get started.

Creating a Node.js Project with Visual Studio

Let's get started by creating a new Node.js project. Let's use Visual Studio to create the new project. In our case, I'm going to start with a blank Node.js web application and we're going to add the different pieces. Some of this would already be done for you if we started with a blank Express application, or even an Express application specifically for Azure. But we're going to start blank so you can see how all the pieces work together. We're going to name the project TheBoard. This is going to be a simple website that can show post-it notes in different categories for users, for both anonymous users and logged on users. So over on the right hand side of our project, we can see that one of the files in here, the server.js is bolded. That means that Visual Studio knows that that is the startup JavaScript file the Node package. Let's also look at the package.json, which we explored a little in the last module, and this is going to be the JSON file for our project. Let's go ahead and give it some information like a version, let's assume we're going to start with maybe a 0.1, we'll call this A message board based on sticky notes, and I'll go ahead and say that I'm the one who authored it and what my email address is. This file is going to be used as we add new packages to our project, but we'll see that in a few minutes. Back in the server.js, I'm going to get rid of everything here for a moment. I really want to start from a blank canvas so you can see all the pieces that are being used. One of the built-in libraries that you're going to want to use is the HTTP library. This is the library that's going to allow you to listen for requests to the server and then respond to them. So we're just going to use require and ask for http. You'll see that inside of Visual Studio you're going to get IntelliSense for the different things you might be typing for require. The Visual Studio support for Node attempts to help you find the right packages. These will be packages that are included in a project. HTTP shows up because it is part of the standard Node base library. Next we're going to want to create a web server. We can do that by calling http.createServer, and then give it a callback function. This function is going to accept a request and then a response variable so that every time we make a request, we'll actually see it here. So let's just use console.log and let's see what the request URL is for our server. Our server has been created, but we're not listening yet, so we just have to call server.listen, and then give it a port number. There are several ways to get at what port number you're actually going to be using. Actually a number like port 80 would be a public-facing web server, but I'm going to do 3000 since we already have other services on my machine that are listening under port 80. We can make this a configuration detail later. Let's go ahead and run the project, and now it's in a state where it's waiting for connections. So I've opened up Firefox, which is my preferred development browser. You can use Chrome, you can use IE, whatever browser you want. And we can see here a slash appeared. That's because we are requesting, but not fulfilling a request to the root of the website. Let's change this to foo/bar/quux. You can see that appeared here as well because all requests that are coming in are coming into this one callback function. So you can see here that the call is just simply stuck in this connecting state, and the reason is that we haven't told the response to send anything back. So even though it's hitting our callback function, that callback function is expected at some point to do something with that result object, usually in a callback to let the server know, and this is one of the things about Node that's very different from ASP.NET in that you're expected to vary yourself from the code that collects let's say data into the views or into the ASPX pages that do that sort of work in a fairly synchronous way. Node instead is saying oh, the callback is being fired with that response, it's going to expect that you're going to use that response object to send something back to the browser. So instead of figuring out how to do this by keeping some state, it's waiting for that response object to actually have response.end be called, that would end the response. So let's come back here and do something with this. So here in the server, we can say res.end, and this is going to complete the operation, but it isn't going to send anything back. We actually have to call res.write to write some information out. And let's write a simple HTML file, and then inside the h1, let's go ahead and just pass in the URL itself. So now no matter what request we get, we're going to return a small piece of HTML that includes that URL. So there's the URL we requested. If we go to the root, we'll get the root. If we go this/is/fun/don't/you/think, the interesting thing about what's going on here is that we have one callback that is attempting to handle the entire process. Writing your own web server this way is possible, but it can be really laborious. And so we want to use some middleware, some framework code like we would in the .NET framework like we think of ASP.NET in Node.js to write some structure to simplify this process for us instead of us having to essentially go back to writing the Windows loop version of a web server project. Let's do that next.

Using Express.js

Next, let's look at the Express framework. In Visual Studio's node extension, you'll notice that there's an npm node right here. And in fact we can right-click it and say Manage npm Modules. This is going to show you what local packages are installed, being able to search the npm repository for named elements, or in our case, we know what we want so we can go ahead and just put a package name in here. I'm going to look for express, and I want to install it locally into my project. This is like making a reference or using NuGet to add a project reference. Once we do this, we'll see that under npm, express, the current version that we downloaded, is shown here, and if we open it up it'll show you the other projects that it depends on that it went ahead and got as well. These are actually installed in a folder called node_modules in that same structure. Node_modules has our express in it, and express has a node_modules that has its dependencies, much like we saw in the first module. What may not be obvious is that package.json now has a folder for dependencies. The project now knows that Express is required so that it can be rebuilt from those dependencies. Again, this is much like NuGet being able to rebuild the list of requirements, being able to download and install required packages on build. This doesn't do it on a build, but it does give you the command line procedures for doing that. This package.json is how the board knows itself what npm projects are installed. And that's important because if you don't want to use the built-in tooling here, if you want to use the command line npm, which is certainly a valid way to do it, and you should probably be used to it if you're going to do Node because there's going to be a lot of tools that are either going to require, or simply be easier. So like we've seen in the last module, we can use npm to install something, and let's go ahead and bring in underscore, because we'll actually need it later, but we're going to want to use the tag of save to install it into that package.json. When we do this, and we come over to the project, we can see that underscore now magically appears. That's because the ---save changed our package.json to include the underscore project, therefore the project already knew about it. There is no build in Node of taking that JavaScript and building something with it, it's simply the matter of reading that package.json that's going to be used when you start up your Node project. Now that we've expressed, we're going to want to do something with it. We're going to first want to require express since we're going to need to use it to start up our server. The express dependency that we have a reference to now can be executed like a function and it will return to us an object that represents our individual app, a singleton that represents our web application. So we normally call it by calling express, and then executing it like a function. In the case of this app object, we can tell http to create the server using that object. It'll know that that app object exposes an interface that will capture those callback functions, and then do what it needs to do to respond to requests. So, if we replace our callback with this app, we'll now have an Express-driven Node application. And now when we make a request, since we haven't told app what data to return, it's returning a small error and says we cannot do a GET on slash. And if we do other calls, it'll do the same thing because we've never told Express that we want to actually respond to something. So let's tell it to respond to something. The app object here responds to http verbs using methods. So we can simply say app.get, and then give it what is the URL it's going for, in this case the root of the page, and then a callback to know what to do with it. And like before, it's going to supply us with a request and response object that we can fulfill for this individual GET. And now we can simply use the response, the response now has helpers to simplify it by allowing us to do things like sending data via the response. Before we had to write to the response and then call end, send is a helper function that will get you there a little quicker. Now that we have our response being handled, let's go ahead and run this. And if we execute at the root, we'll see now we're actually getting a small little web page. We view the page source, we can see that we're getting exactly what we sent from the server. And in this way you can write your code in a pretty simple fashion of being able to deal with what URLs are being hit and then what code is being written. And if that sounds familiar, it should, because this is really the relationship between a route in ASP.NET MVC and a controller, or more importantly, a controller method in an MVC controller. And so later we'll convert some of this code into things like controllers that might be even more comfortable. But what I like about this approach is it's allowing us to deal with the HTTP verbs in a very straightforward, native way. We're not trying to pass them into some weird machination, we're really just handling them as gets and posts and puts and deletes so that we could do app.post as well, and then have some callback function. And even if we were going to be dealing with building something like an API, we can do that using the same syntax. The fact that we're returning HTML isn't all that different from the fact that we may be returning JSON and other methods. So let's do a get API users, and the syntax is the same, request and response, and in fact the send is even the same. But what are we going to do with the send? We're not going to send a string in this case, we're going to send an object or an array. By sending an object, Express knows that what we really want to be doing here is serializing it as JSON. So let's run this, and there we're getting JSON back. We can even control headers by calling set so that we can add the headers we need to make these operations exactly the results we wanted. In this case we're setting application/json, and that is something inferred because we're sending an object, but certainly we could be using custom headers as well, or we could be using custom content types for things like versioning. And when we look at this response, we'll see that the response included the header of application/json because we set that content type. We could be adding new headers here simply by using that all to set under the response object. Later in this course we'll be talking about building APIs and some of the complexities there. But we're going to focus on really building a website in this part of the course. One of the problems we have here is we're not going to want to build our html using magic strings, that would be painful. So there has to be a better way, and that better way are view engines. And we'll do that next.

View Engines - Jade

So now, let's take a look at a view engine and see how that works. Like I said earlier, you're not going to want to use magic strings to put together HTML, you're going to want to create them as something like a view. The most popular of the view engines out there, the one you're going to see most used in Node, and in fact a lot of the sample projects or even the Visual Studio new Express project is going to use a view engine called Jade. So I'm going to show you that first, and then we'll talk about some alternatives. So if we use npm, we can go ahead and install Jade, and in fact, it's just called Jade. I'm going to go ahead and save it to our project. And Jade is a view engine. So to set up the view engine, we're actually going to use app.set to set with the magic string of view engine the name of the view engine we're going to use. In this case that's going to be jade. Now we don't need a require here because we're giving it the name of it, and then inside of Express they will go ahead and do the require to actually use Jade as a view engine. Once we have the view engine set, we can avoid using this ugly syntax of just using strings and use a view engine to do it instead. We can do that by going to the response and using the function called render. Render is going to want a path to a view file. So I'm going to put it in a subdirectory called jade, and then I'm going to call it index. Index is going to be the view name itself. And then I'm going to give it some state. And I'll just say Express + Jade as the title. And this is going to be an object that's passed into the view that it can use to change elements about the page that are being rendered, just like in ASP.NET, whether you're using Web Forms and using the angle bracket percent syntax or whether you're using Razor in ASP.NET MVC, this is essentially the same. This ends up being that controller that says go find the view and send the view this data to render as the view. So let's go ahead and create that view. All the views inside of Express apps expect that they're going to be in a folder called views. So when we give it this path syntax of jade/index, it's going to start at views, and let's create a new folder for jade since we specified that as the start name of our view, and then go ahead and create a new text file called index, again, just like we did in the call to render. The extension for this is going to be a .jade file. The syntax for Jade is a Haml-like syntax that uses indention to infer nesting. So let me go ahead and paste in a simple version of the view we're going to use. So this syntax tells it to create a doctype and then an html tag and then a head tag and then a title tag. This nesting is inferring parent/child relationships, and in fact these are just the names of the tags. Some people prefer this syntax because it's very terse, it allows you to write these views very quickly, but it does mean that if you're dealing with any external resources that are giving you things like wire frames and HTML, you're going to have to then convert them into this format, which is why I'm not entirely pleased with Jade and I tend to use one of the other view engines we'll talk about in a minute. This equal syntax you see here is how it's taking the values that are being passed to us from the render function and using them in the views. So if you remember, we're passing an object that has a property called title, therefore we can go ahead and just say equals title to get that property out of the object and spit it into the resulting HTML. We're also putting it in an h1 tag. Let's go ahead and run this and see if it works. And there we go. We can see that the title for our HTML is that string we sent from the render, as well as it's being spit out here inside the Jade tag. Let's stop this for a minute and let's talk about another type of file, and that's something called the layout file. This is another text file that is going to represent the master page for Jade projects. So much like you're used to using master pages in ASP.NET or using layout views in ASP.NET MVC, this is the same concept. And in fact we can go ahead and grab the majority of what's here and put it in our layout, and then we can specify block and then the name of a content block, which I'm just going to call content, and then we can include some other elements, like let's go ahead and give it a footer of This is the footer as the content for that object. And then over in our regular Jade file, we can have just the elements we're expecting. In here, we simply say extends layout. So this line here tells it oh, go use the file called layout.jade as the main part of the page, and then from extends layout we have to tell it what part of the page we're going to inject into. So in this case we're going to use that same line, block content, and then we're going to provide the block of content. And notice we can use the title here because it's being passed into the entire view. This is going to bring in the top part of the view so we can also use that data here in the layout still. So we're really building these layouts or master pages, whatever you want to call them, using Jade in a pretty simple fashion. Let's go ahead and show this working. And there we have it. See the footer is below and that we've created this section on top of our HTML to sort of insert it in there so that most of the rest of the views we're going to be creating should be pretty simple and small like this, we don't have to repeat the HTML for each page. You're already doing ASP.NET or ASP.NET MVC, you're very comfortable and familiar with this pattern. But I'm not a big fan of Haml because I want to use other assets that I have already at my disposal as snippets of HTML. These snippets mean that I want to be able to write my code using HTML. So we're going to look at two other view engines, the first of which is going to be pretty comfortable for those of you who are using ASP.NET Web Forms, or for those of you who are using the older view engine inside of ASP.NET MVC. This view engine is going to have a very familiar syntax to you guys. Let's take a look at that next.

View Engines - EJS

Next, let's look at a view engine that is more Web Forms-like. So because we're not going to use the Jade engine, let's go ahead and comment that out, and let's include a new package called ejs that stands for embedded JavaScript. It's a view engine that allows you to use JavaScript inside of bracket percent constructs inside the view engine. We also need in order to support master pages, we're going to need a project called ejs-locals. So we'll go ahead and install that one as well. Now you can see we have these two projects. So we're going to need an instance of the ejsEngine, which is that ejs-locals dependency. We can call engine, which is going to tell it that we want to insert a certain kind of engine into our project called ejs, and then pass it in that ejsEngine that we just retrieved from getting the require for ejs-locals. We also need to tell it what view engine, just like we did before, for Jade, but this time it's going to be called ejs. This line is the code to support the master pages, and this line is what actually makes ejs work as a view engine. So you can get away with just a second line, but you're going to lose the ability to handle master and detail pages. All we're going to do on the render side is just change the path here and the text so we can see that it changed to a different subdirectory. We're actually going to keep the same pattern of the index in the layout file. So let's create that new folder and let's go ahead and create a new text file. So unlike Jade, ejs can handle actual markup in the form of HTML, but it introduces the syntax of angle bracket percent to allow you to write server-side code. This is actual JavaScript, that's why it's called the imbedded JavaScript engine, because here we're taking that object that was passed into the view and specifying that we want to take the title property and inject it here. The dash indicates we want to inject it. There's a couple of different syntaxes here for what you want to do. Without it is actually just creating a code block, again, much like ASP.NET Web Forms. There's a few others that you'll want to use, but on the whole this is pretty simple, right? We're just using the same sort of syntax we did with Jade expect we're allowing us to use full HTML. So with luck, this should work. So now we can see we're getting the Express EJS injected just like we did with Jade, so I don't need to belabor that, that syntax is pretty comfortable if you're coming from the Web Forms world. Let's go ahead and create the layout page for that as well so you can see what that syntax looks like. In this case, we're going to move all of what we had in the index into the master page, and here we're going to include body. The body tells it that whatever we find in the index.ejs in our example, go ahead and inject it here inside this div. So the first thing in these partial views we're going to want to do is we're going to want to tell it what layout to use. So we're going to use the function called layout, and then just point it whatever that layout file is, there could be more than one. And then we can just go ahead and use that syntax, and then we can just put some more syntax, like This is from, and then this should work. Again, the partial views rendering inside of the layout. Make sense? Even though EJS is compelling if you want to stick with that same syntax, my recommendation if you're moving with Node is to actually use a third engine that I've grown to like. That engine is called Vash. The importance of Vash is that you can use razor-like syntax so that you're really mirroring what you probably would use in building ASP.NET MVC projects today. Let's take a look at that next.

View Engines - Vash

So now let's take a look at a razor-like view engine called Vash. To start out, I'm going to just comment out our old view engine that we did in our last module. Let's go ahead and grab the Vash dependency. And it is just called Vash, V-A-S-H, and all we need to do to use it is say app.set view engine, I think you're starting to get the hang of the pattern here, and include Vash as the type. I'm going to come down and change our render here to just say index. For the balance of the course, all the views we're going to deal with are just going to be in the views folders, so I don't need that prefix to specify what folder it's in. Later on as you want to create structure based on controllers, you may want to reintroduce folders, but for our example it should be pretty simple. And I'll just say title is going to be Express + Vash. So let's go ahead and create that index view, and this would be index.vash, not surprising. In fact, I'll borrow the HTML from our ejs file because we can still use HTML inside Vash files, but instead of using this syntax to get at the title, we're going to use @model.title. Model is going to be the object that is being sent into the view, so in our case that's just going to be @model.title, and I'll do the same thing here, @model.title. Now that we've refreshed, we can see that we're getting that Vash syntax being dumped out here. Let's go back here and create a new layout file just like we did before with the other view engines. Like we did before, I'm going to just dump out our main HTML into our Vash file and get rid of it from our index. And then in our div here, instead of calling title, we're going to want to tell it to inject it here. In the case of ASP.NET MVC, you're probably used to doing this as html.partial. Well that's similar here, it's actually html.block, and then you're going to give it name, and I'll just call that main our body. Now back in the index, what we're going to do is a little different in that we're going to use JavaScript blocks to really infer different parts of our page. So the first thing we'll need to do is call extend, html.extend, where we're giving it what is the file that is the layout we're looking for, and in this case it's going to be the layout.vash, it will infer the .vash, so we can just include there, and then it's a callback function to render the rest of the page, passing in the model that was being passed to this page. And in this way, we're passing the data from this outer section into the callback for this model. So that shouldn't be all that surprising how that looks. And then we're going to do the same thing for block and give it the name of the block we're trying to fill, which in our case was body, and we're going to pass that model in as well. And now we can just define what's going to be in the block. Let's have an h1 and then let's go ahead and have a little paragraph tag. And here we can use that syntax again, @model.title to inject it on that page. So this is tying it to the layout page, this is tying it to the named section on that layout page. So with luck, we're now getting Vash from the server using a layout file, as well as the markup for our particular view. So one of the things you'll notice in this is that we've got this dangling semicolon, I wonder what that's all about. If we look at this we'll see that by default, by nature because I've been writing JavaScript in C# for so long, I put semicolons at the end of these. They're not necessary and they're not needed or useful. In our case, because we had a semicolon here, it ended up being injected into the page. So if we remove them and go refresh the page, we'll see it delete, and this is one of the ideas. This vash file is re-rendered every time, so as you're doing development, we didn't actually have to restart Node just because we used the Vash file. You can do some things about caching that index manually later, but for the most part you're going to want to, especially for development, be reading them from disk every time. So next, let's move some of our routing information into controllers and see how that all works.

Building the Controllers

So now let's create some controllers. If we come back to our project and create a New Folder called controllers, and inside of it we'll add a new JavaScript file, and I'll just call this our homeController. This is going to contain the routes or the gets and the posts, the puts, and deletes for the main part of our website. It's going to be the controller for the web pages themselves. So one of the patterns when I'm creating services or controllers, or other kinds of pieces that aren't the main JavaScript file for Node, is I like to put them in a self-executing anonymous function. Normally in the browser I do this so that I can avoid the global scope. It's not as much of an issue with Node, but what it does allow me to do is create something that's a little more readable and modular. So in this way I'm passing in that exports object and renaming it to homeController so it's really clear to me as I'm reading it that I'm adding methods to the homeController like I do here. I'll create an init function, and in this case I will accept from the init function our app object. And then what am I going to do when I initialize the homeController? I'm going to handle, I'm just going to move this get over to my homeController. So what the homeController itself ends up becoming is the container for the different request types that are going to happen for let's say the home part of the web page. I've seen some Node projects where they do all the gets, posts, puts, deletes directly here in that main JavaScript file, but it gets messy and I like to modularize what I'm doing so it makes more sense. One of the tricks we're going to use here though is we have a folder called controllers that has our homeController in it now, but I'd like to have this folder be fairly self-referencing. I would like here in the server.js to be able to simply say var controllers equals require controllers. And this will give us access to all the controllers, but in order to do this like we've seen before, I'm going to need an index.js. And in this case I'll use the same pattern I did before, call it controllers this time, and then I'll simply say controllers.init, and I'll create that same pattern with accepting the app object. And then what will I do when I initialize the controllers themselves? What is it that I'm going to initialize? I'm going to initialize each of the controllers separately, so this ends up being the traffic cop to handle all the initialization of wiring up all those operations that need to be done. So here I can require just the homeController, and later when I add new controllers I'll need to add them here as well. Let's change this to Controller, and then this way I'll just wire up each of the controllers inside of the controllers.init so that the server page is only going to know about the initialization of the main controllers. This way in our main code, we only have one place that that is really responsible for handling the routes of our whole project. We have a modular way of sort of breaking up each of the routing information into individual controllers, and the individual controllers therefore will handle the handling of individual routes and what to do in those routes like rendering. Node projects can take off pretty quickly, much like .NET projects can, and so starting to imply some of the structure, some of this formality into your Node project early on will pay off greater later. You're not going to want any of these individual JavaScript files to be very large. If you find a file that's 1000, 2000, 3000 lines long, it probably means that you're not modularizing quite enough. It also means later when you start testing your Node application, you're going to have these modules that can be tested instead of trying to just test the endpoint, the result of what an individual web page can do. So far we've created a controller that really has the same functionality, so if we run this, it should continue to work, and there it does. So now we're just sort of emitting simple HTML, let's talk about doing something more sophisticated. Let's create our first servicing note.

Building a Service

So let's create our first service. Now when I talk about service, I really mean just a component that does some things for other components. So in this case we have our homeController that has the home page that we're sending some nebulous title information in, but we might want to send some more interesting data into the website. So that's where a service can come in. Let's create a new service called the data service, and I'm going to do this in sort of the same behavior, I'm going to create a folder for the service, which I'm going to call data, and then I'm going to add an index JavaScript file that represents a starting point for that service. Again, we'll create a self-executing anonymous function. So let's add our first piece of functionality to our data service. And I'm going to create a function called getNoteCategories, because in our website we're going to show a list of categories on the home page and then allow people to drill in and see all the notes and eventually add new instances of notes. Because this is asynchronous by nature, we're going to actually pass in what to do next. So we're going to go get the categories and let's assume that this may need to be an asynchronous operation, getNotes might need to go to some data source, read some data and what the data has returned, then we can call next to tell the caller that we're done either with a success or a failure. For now all we're going to do is just stub out some data. But I'm going to stub out the data using another JavaScript file that's going to represent what I call the C data. This is going to be the data that's inserted into the datastore we use later as the initial data of our system. So I'll simply here call next because we don't need to have an asynchronous operation yet, we'll refactor this later to do that, and for the first parameter I'm going to pass in a null, which means there was no error because we know pretty much what we're looking for. And the second parameter is going to be the seedData.initialNotes. So where does this come from? This comes from a require. We're going to go look for a seedData JavaScript file in our same directory. The reason this is an interesting approach is that the idea of seedData or maybe the database we're going after or the initialization information about that database are all sort of private information about our data service. So the index ends up being that public interface to it that may internally use other components that are part of this folder. So we're talking about composition of this service from other pieces that may or may not be public parts of the data service itself. So you've been through the drill already, you know that we're going to use a self-executing anonymous function, and then here I'm just going to seedData.initialNotes and I'm just going to paste in some sample notes I have. This is going to be an array of categories. You'll see that this first object has a name, and then has a property called notes that is then an array of individual elements. Let's just be the initial data that we're going to return as the seeding data. Later on we'll use this to actually seed the database when we create it. Now that we have all this, when we go back to our homeController, we can go ahead and create an instance to the data object. Here we'll have to go dot dot because we're going down one level and then grabbing that data, and then we can use it here. But of course, it's invoking a callback, so what do we do to actually use it here? Data.getNoteCategories was the name of the method and we're supplying it that callback, that next function, error, and I'll call that results. And here I'm just going to pass both values in as part of the model so that I can data bind against them both. If there's an error I'll show the error, if there's categories I'll show the categories. Notice since this is a callback since this might be happening asynchronously, that it's still following that same pattern that Node follows, and that is it's the callback, it isn't until this render happens that the request succeeds. You don't have to deal with hanging on or telling the server that this is going to happen on a callback or any of that, it knows that once the get happens, to wait around until someone renders, sends, ends, writes, something to that response object. Now let's go to the index.vash and make this actually work. So I'm going to leave the title in there for now, and I want to be able to write out the error. So what can I do? I can say @if model.error. So what is happening here? This is razor syntax, but it's razor syntax against JavaScript. So I can say oh, if there is an error, then write this block of code here. If the error doesn't exist, if it's null, then this is going to pass by and it's not going to render this line. And then I can just use the razor syntax again to say @model.error, and it'll spit that out in our little piece of code here. And I'll include a class so that's nice and colored red. In our case because we were passing back the result, if there were an error, we're still creating that category property, but that category would be null. So we can actually use this syntax. This is using a forEach with a callback so that for each item in the categories, we can go ahead and simply display the name of the category. We'll just wrap this with a div so that we get one per line. And then we can create a quick span that's just going to show the number of notes in each category. And in our case, we're just going to use a small piece of Vash syntax. So the at with parentheses around it means it's going to compute it into a single atomic expression. So in this case I'm going to say if there's category.notes, then show its real length, otherwise show 0 in case there aren't any notes for a particular category. If we run this now, we'll be able to see that not only the categories, but the number of notes in each of those categories. Now we're getting some functionality here, but it's pretty ugly, so let's talk next about resources like CSS and images.

Static Resources

So next, let's talk about static resources. Because we've got things like controllers that are using app.get to return things like HTML pages, there doesn't seem to be an obvious way to get at our local resources like CSS and images and even our own JavaScript files to be served up as plain old files. Express requires us to sort of opt into this as a feature. Let's create some static resources first. I'm going to create a new folder that all my static resources are going to go in called public. This'll just be folder by convention called public that's going to contain all sorts of files that the website is going to need, images and fonts and CSS and JavaScript and flat files, whatever you think you're going to need, this is a good place for it. And I'm going to create another subfolder to hold our CSS sheets. And I'll go ahead and create a new site.css. And our CSS sheet is just going to have a little bit of CSS. So we're going to change the size and the face of the font, and we're going to change the color of the font to just off black as I like to call it. If we open up our views and go to our layout, this is something typically you're going to have in the head of your layout file is something like a site-wide CSS. Visual Studio is going to let us drag it over, but it's trying to guess where we want it. So it thinks it's going to be /public, and the problem with this path that it's giving us is it assumes that by default, every file on the web server is accessible from the browser, and for very good reasons you don't want that, you don't want your server.js, you don't want your server-side JavaScript ever being downloaded so they can see how you're decrypting cookies and decrypting passwords and those sorts of things, none of that code deserves to be accessible from the browser. So what we're essentially going to create is this folder where everything is the root of the browser. So we can now just remove everything before public, including the word public, and when we go to /css/site, it's going to attempt to look in this public folder. On the face of it sounds pretty good, except if go ahead and run this now, and we go ahead and run it, we can see that the site css isn't being found. And the reason it's not being found is we haven't told Express that we want to allow public static resources to be downloaded. So we can do this by telling the application to use a piece of functionality called express.static. This is a handler for all things static, and what we have to provide it is the name of a directory. We have to give it a full path, but luckily there is an implicit variable called _dirname, which is the root directory name of our Node application. So we can add this to /public, give it the correct number of parentheses, and this should work. Let's go ahead and run this. And if we refresh it we can see that the site is now getting a 200 OK and obviously the look of our site changed just a little bit. This is going to be useful because we're going to serve static resources that are ones we authored like site CSS or images, as well as ones we don't, including things like the Bootstrap, JavaScript, and CSS including jQuery scripts, including Angular scripts, all of that are other assets that are going to go in this public folder. We'll do that next.

Client-side Resources

So now let's talk about handling client-side resources. We showed you in the last video that we can use the express.static in order to allow static files to be served directly from node. Now that we have those, we may have a need for using third party libraries. Now we could go to each website and download them manually, but that sort of goes against the instincts of the project, we're already using npm to bring down server-side components and modules, why shouldn't we do the same on the client. And we can. In fact, it's a facility built using Node called Bower, B-O-W-E-R, or Bower, I've heard both pronunciations. Let's go over to the command shell and let's talk about getting Bower. Bower is actually in the Node package manager directory, so we can say install bower. And I'm going to introduce you to a new like here that says ---save-dev. This is going to save it into your project's package.json, but it's going to save it in a very special way. If we look at the package.json now, we'll see there's a new section called devDependencies. These are dependencies that aren't required when you're pushing this to a production server, they're only dependencies that are required when you want to develop against it. In our case, we don't actually want to use bower locally, I want to install it globally so that any project I use can use it and I don't have to end up reinstalling it over and over again. So I'm going to use npm again, but I'm going to say uninstall, but this time I'm going to also give it the --save-dev, and I'm giving it the flag so it knows that I want to not only remove the binaries, but remove them from you guessed it, my package.json. I'll go ahead and install it with a --g, which means to install it globally in Node so all my Node projects can use it, or in fact, because I'm using Node everywhere, any command shell can use it. So now we have Bower installed, how do we use it? Let's assume that on the client-side code we're going to want to use certain resources like Angular and Bootstrap and jQuery and even Underscore. So let's install Underscore with Bower, and you just use that by using a command called bower and install. You'll notice it's taking its same pattern from npm, and we're going to give it a package name, and I'll call it underscore. It got it and created it under this folder, bower_components. Let's go over here and see that it's installed it by default in a folder called bower_components. This would be fine except that it's not inside of our public folder so there's no way we can actually use it on our pages. So let's go ahead and uninstall it temporarily using Bower, and let's solve that. Bower uses a file to configure itself, and I'll just create a quick file called bowerrc and Visual Studio doesn't like you to start any names with periods, so we're going to get rid of bower and we're going to include the .txt and then we're going to rename it because we know better than Visual Studio at this moment. The file is actually called .bowerrc, on extension, and in it we're just going to create a small piece of JSON that tells it different options. And the only option we really care about at this point is where we want those resources. So the directory that we want bower to use for installation is going to be public/, in my case I've decided that all third party components will be in a lib folder. Once this file exists, we can reinstall Bower and watch it throw an error. This error is something I'm hoping will be fixed in Bower soon, it's sort of an annoying error. The problem is that the bowerrc file is by default saved with a different encoding. It's saved by default with UTF-8 and Bower doesn't recognize bowerrc files and UTF-8, so we have to do a little trick of File, Save As, and then use this little drop-down to Save with Encoding, and instead of UTF-8, just pick the Windows encoding. Sort of the opposite of what you would expect. So let's try to install it again, and it installed it, but this time it installed in public\lib. So here's now our libraries that we have through Bower. In this case it's Underscore and there is our underscore.js. So if I open up our layout, I can simply drag it from the lib folder over here and again fix the paths to not include the ../public. And now every page will have access to Underscore. So now let's go ahead and install Bootstrap, and we go back and look at our lib folder, we'll see there's bootstrap, as well as jQuery, because bootstrap requires jQuery. Just like npm, it's going to walk those dependencies and install all the interesting pieces. So I'll go ahead and grab jquery.min since we're using Bootstrap, and then I'll go ahead and grab bootstrap.js. Now in Bootstrap they don't put them here at the root, they're actually in a dist folder under js. So let me bring that in as well. We're also going to need the stylesheets. So here in bootstrap.css, I'll bring the min version in and then the theme version, which I just like to make it a little prettier. So we're able to grab all these from that new lib folder and all should be good, but of course we're not really using Bootstrap in our project yet. So let's fix that. Instead of just a single div that's showing our body, I'm going to replace it with some Bootstrap boilerplate that I have saved in a file in the resources directory, for those of you who are following along, call layoutbody.html. Now in this course I'm not really covering how Bootstrap works or any of that, I have another course on Bootstrap 3 that I encourage you to go watch if you want to understand how to work Bootstrap, I'm going to assume that either you've done Bootstrap or you know how to copy a file into another file. In this case it's creating a nav bar on the top for us, and we still have that same block body in the middle of all this, but it's going to contain our whole object in a nice Bootstrap container. Now that we have the body blocked out, let's make some changes on our index.vash to also support the different change. I'm going to surround our forEach with a couple of divs that will give us a list group sort of look to our page. I'm also going to give this a class of badge, and let's get rid of that dash because it's not going to be needed anymore. Now that we've added the badge, we also need to add a class to our anchor tag called list-group-item and list-group-item-info that makes it look like a list item itself. And let's get rid of this div that surrounds it, and we're going to move the span inside of the href. And this is all Bootstrap formatting so that we can get a nice list view for our page. Go back to the page, and now we're getting mostly what we're looking for. This is now that list view. Notice it's showing and linking us to each of the categories, as well as showing us how many, it has a little badge on the end. We're getting this double Express and Vash because we still have the model title on our page. If you noticed on our new layout, we're already including this on every page as the page header, so we can get rid of showing this so it's not duplicate. And we also need to make a small CSS change, since we're now using that header we need to add a margin-top of let's say 50. Now that looks much better. We're getting the title of our page, we're getting our list view, and so we're using these third party components, we're using Bootstrap and jQuery, we've included Underscore, but we're not using it yet, and we're starting to get that look and feel of an actual website, not just some random HTML being spit out of the browser. A lot of the work we've been doing here though requires us to restart Node over and over again. We're not doing a whole lot of debugging at this point, but we are doing a lot of changes and refreshing of the Node project. This ends up being a bit of a pain, and in our next video we'll show you how to improve that.

Speeding Up Development

So for our last part of this module, we're going to go ahead and show you how to use GruntJS to improve Node development speed. A lot of the changes you'll be making, especially to individual markup files or in individual controllers, you're not essentially having a problem every time, you're just making some changes and would like to test it in the browser. Restarting the project in Visual Studio every time is just too slow for my taste. When I need debugging, running it in Visual Studio is perfect, but I'd like a way where it's going to refresh itself a little bit faster, more like the client-side experience I have when I'm just spending a lot of time refreshing in the browser. We can actually accomplish that pretty easily. What we can do is install a project called GruntJS. GruntJS is what's called a JavaScript task runner. In fact, there's a whole course on Pluralsight about GruntJS and a lot of nifty things it can do. We're going to use a GruntJS plugin called nodemon that will restart Node every time we change some files. But first, let's go ahead and use npm to install grunt-cli and I'm going to install it globally. The way that Grunt works is it looks for a file in the root of the folder it's being run in called gruntfile.js. This isn't a file that's used by Node at all during runtime, it's purely a development asset. And the way it starts is it exports a function as the entire gruntfile, and of course this pattern should look pretty familiar to you. And this function that will eventually be executed by Grunt passes in this object called Grunt that we can then call initConfig with some information about how to configure Grunt to do whatever job we're looking for. For us, we're actually looking for it to use a plugin called nodemon. So, we first need to install the plugin. We could do that with npm as well, and the name of it is grunt-nodemon. And here I'm going to save it as a development resource. We are going to install it in this case in our local directory, not globally, because we're going to use Grunt locally in our project. And this is the one plugin we're going to use for now. You may later decide to add other ones to do things like run your tests, minimize your CSS and JavaScript, run JSLint or Hint, those sorts of things. But for us, nodemon is really what we want. Nodemon has a small number of configuration options. So here we're going to extend the configuration object that's being passed in with a named object called nodemon. It knows that nodemon is going to go with the nodemon extension, and you'll see how in a minute. And we're going to say in all cases, our startup script is going to be called server.js and we're going to restart this if any files that end in js are modified. Now you might think why don't we run this when Vash files or CSS files are changed, that's because they aren't required to be refreshed in node, they're not cached, whereas the server-side files like the controllers and the services, once they're read by required, they're actually cached in memory, so we need to restart Node in order to effect those changes. Once we have this configuration file specified, and there's other options you could take at later, we're going to first tell it to load our nodemon as a plugin, we need to tell Grunt that that's something we need to do, and then we're going to register that the default behavior, in other words when Grunt is run the default thing to do is to run nodemon. So how does this work now that we have the Grunt file working? If we come into our root directory and we just type the word grunt, it's going to start our Node server for us. What this allows us to do is if we come in here and go the server.js, or really any js in our directory, let's go ahead and just make a non-change, we just had to save the file, and we can see that it said restarting due to changes. So every time we make a change in the background, it's going to restart Node for us so that the new changes can take effect. Let's see this actually working. So we look at our controllers. If you remember, our title is Express + Vash, and if we refresh our page, we can see it says that. This is in a controller so that if we made this change without nodemon, we'd have to restart the Node server ourselves or press F5 in Visual Studio, but in this case we'll make the change and give it what the actual board should say. And when we press save, we'll see that it restarted it again, and if we refresh the page, it now says The Board. So in this way you can continue to make changes to your server-side code and very quickly be able to retest it without going through the whole restarting of the server over and over and over again. What I find compelling about this, is that I find that most of my changes when I'm working with Node don't require the debugger. But of course, if I need the debugger, I can stop the grunt task and I can still run it, and it's perfectly the same, right? It's still going to work, they're both running the same node code, just in this case we're going through the extra step of attaching a debugger so that we can actually see what's going on if we need to. Great. Let's wrap up this module.

Summary

So what've learned? You've seen how using the Express Framework and Node.js should be pretty effective in writing web applications with Node, certainly easier than doing it yourself where you're having one callback that handles it all. We've looked at three different view engines to see the pros and cons of using them. I picked view engines that I thought would be particularly helpful to .NET developers. There's certainly other engines that appeal to other kinds of developers. There's a handlebars engine out there for people who've done Ruby on Rails for instance. The idea is that you can pick the view engine that matches the skillset that you're bringing to Node.js without having to sort of adhere to what it's doing for its own view engine. We've seen that building routes using controllers should feel pretty familiar to ASP.NET MVC developers. For Web Form developers, it's going to be a little bit uncomfortable because you're used to being very paid-centric and there's nothing about Node that is paid-centric at all. It's really about responding to individual requests and then mapping those to data logic and then ultimately to views. I also showed you how Bower can simplify getting client-side libraries so you don't have to manually be copying in one library or another. And finally, I showed you GruntJS and nodemon together to simplify development so that the node web server could be relaunched every time you make a change so that you can have that very quick process. You're still going to have to drop down into Visual Studio occasionally to do debugging, but I found that the debugging experience is one that happens less often than you might imagine. Thanks for joining me for building a website with Node.js, my name is Shawn Wildermuth of Wilder Minds.

Accessing Data with Node.js

Introduction

Next we'll be talking about how to access data with Node.js. This is going to consist of how accessing data is different in Node.js from normal .NET development, whether you have to use NoSQL databases or not, I'll show you how to access SQL Server data, then I'll introduce you to Mongo, one of the document databases that's pretty common in use with Node.js. I'll show you how to install MongoDB, how to store data in MongoDB, and how to retrieve data in MongoDB. Let's get started.

Data Access in Node.js

Most of the time when you're building web projects, you're dealing with data in some way, whether you're going out to a web service to get it, whether you're using a local relational datastore, whether you're already using a document database, and all of these options are available in Node.js, but it is a bit different than ASP.NET. Ordinarily when we do ASP.NET, we're relying on a data subsystem to handle interacting with the database for us, usually in the form of an object relational mapper like Entity Framework or in Hibernate. One of the benefits of Node.js is that you're using data in a natural form that you would use to consume it inside of a web browser. This means you're going to be dealing with JavaScript objects and JSON when you're communicating across the wire. So Node.js deals with data, but like .NET, you're going to need a driver depending on where you're storing your data. This is true for relational datastores, as well as NoSQL datastores. There's lots of solutions out there, they're all going to be different npm packages, but you should research your driver carefully because even something as simple as SQL Server has a handful of different solutions. When you're looking at the different drivers for Node.js, take a look at the age of the repository and the activity level to make sure that it is still a common concern. It was very common go to out there and look at a SQL Server driver repository, only to find out it had been sunsetted by Microsoft or by a third party. It's also of interest when you're looking at these drivers to see how fully-featured they are. In some ways, especially then you're dealing with relational datastores, you're taking a step back because you're not going to be dealing necessarily with an object relational mapper, you're going to be dealing with JavaScript objects, which are typeless, which is much different than you're probably used to dealing with in SQL Server. For me, it comes down to Greenfield versus Brownfield. So if I'm integrating a new Node.js project into a larger ecosystem that already has a lot of code, especially if the data is being stored in SQL Server or Oracle or a relational store of some sort, I'll probably stay there, I'll use a driver that'll allow me to go at the natural relational datastores. If I'm in Greenfield or I'm creating a brand new project with brand new IP, then I'm probably going to go with one of the simpler NoSQL or document databases. You'll quickly notice that document databases are very much the more common approach with Node.js. It doesn't mean you can't use relational datastores, but as you're learning Node.js, it's going to help you to go ahead and learn document databases and see why they're attractive in many situations. One of the challenges as a .NET developer is that you're typically used to interacting with the database with strongly typed objects. But of course since Node.js uses JavaScript, these objects will be weakly typed. There are drivers out there that can help you deal with things in a more strongly typed sense, but one of the things I would suggest is that you give up your .NET prejudices and realize that these weakly typed data structures are about, and that if you give up your strongly typed data structures, you're going to find it easier to work in this new ecosystem, which you're trying to learn through this course. One of the big lessons for me in coming to Node.js is that I found there were a number of systems out there that wanted me to interact with data schema, much like I do with a relational store, I define what objects look like and that as time goes on in order to change the nature of that structure, I deal with updating that schema. This is a very common pattern in the years I've been doing database development. But don't think that because you're using weakly typed schemas, or schemas that are going to evolve over time, and maybe even leave in a document datastore documents of one schema next to documents of another schema and just writing code to deal with the differences, that you have to homogenize all those pieces of data. When you're writing your own APIs that are dealing with that data, don't assume that just because you're versioning means that your data schemas have to also be versioned. You simply don't need data schemas if you're going to version your API, because versioning API isn't always about the data changing, sometimes it's about behavior changing, and sometimes it's easier to hide the implementation details of two different documents that have different schemas behind the scenes in your code instead of exposing that out to your user. My suggestion is not to tie versioning with strongly typed data schemas when you're using Node.js.

Relational Data in Node.js

This is a really common question that I get when I'm talking with developers about Node.js, and that is they assume that you have to use NoSQL datastores or document datastores when you're using Node.js, because most of the examples out there are using things like Mongo or CouchDB or one of the other flavors of document databases in order to use Node.js. In the case when you're writing code that's integrating with other services using relational datastores or simply because it makes more sense for your project means you can use relational datastores, and there's certainly drivers for them. Like we mentioned before, you'll still need a driver for your particular datastore, and there's a handful of them out there. We're going to show you one for SQL Server. One that I really like is massive-js. This is a simple driver that wraps around both MySQL and PostrgreSQL. There's msnodesql that works with SQL Server. This is a native tds driver, it's written in C and C++, but is difficult to get built on Windows. There's also tedious, which is a pure JavaScript SQL Server, but has some limited functionality, especially when you're not working with full instances of SQL Server. If you're working with SQL Express or LocalDB, tedious simply just won't work for you. It has some limited functionality and because it's written in JavaScript it tends to be a bit slower than some of the other drivers. Another option is edge, and edge is a way to write ScriptCS, which is a script version of C# in work with Node. And this way you can call any arbitrary .NET code so you can keep your data access in .NET code through ScriptCS and then interop with Node.js. Those are all different ways I've seen of really handling going out to relational datastores, and as .NET developers, the edge option is pretty attractive, though my only fear around edge is that as .NET developers, that you'll tend to lean into writing more and more .NET code or C# code instead of writing as much of your code in native Node.js as possible. So let's see how accessing SQL Server works.

SQL Server in Node.js

So let's see how accessing SQL Server works. We mentioned that there is an npm package out there, let me pop open a command prompt, and if I do npm install msnodesql, we'll see that it goes and gets it, but throws all these errors, because what is required to actually get this installed is it downloads the package and then tries to install it, and part of this installation is actually building msnodesql from its C and C++ source code, because it is a native driver. I found that getting this to work on Windows is pretty notoriously difficult. Getting this to work on a Mac, I've been told, is much easier, but let me focus on Windows since you guys are .NET developers. An alternative to this is a repository called node-sqlserver-binary. And this is a precompiled version of that same library, they simply checked it in with the binaries prebuilt to make this a little easier for when you're trying to access SQL Server on Windows machines. There's some good docs here on how you would actually deploy this in things like Azure or other GitHub-related repositories. But for us, I'm just going to go ahead and download the package here as a ZIP. And you'll notice there's a node_modules folder. Let's download it as a ZIP and I'll just put it on our desktop. And then when I open it, I'll see that there's some files about the project including a little test JavaScript file, but I'm really interested in what's in the node_modules, and in fact this folder. I'm going to copy this folder over to our project. So I'm going to open up a File Explorer at our project, we see our node_modules, and I'm going to literally just drop it and copy it into our project. This is going to contain the entire package in order to access SQL Server. When we come back over to Visual Studio, you will notice that there is this project and it says it's not listed in the package.json, and this is on purpose. It's not listed there because if we attempted to have it go get this package and download it during an install of this project, it wouldn't know what to do with it because it's not a package that is actually listed somewhere like in the npmjs registry, something we manually copied, and therefore every time we deploy this we're going to need to include that folder, whereas normally when we deploy it to something like Azure or Heroku, it would go ahead and do a get to get all those npm packages for us. So we're going to leave it that way so it's really obvious that it was a hand copied package, but now that we have it, it's still going to work like any other package because the requires is simply following a lookup strategy inside of that nodes_module folder. So it still exists here in that nodes_module folder, so it will find it. So let's write a really quick and dirty example of this. We're not going to actually use this in our larger example, but I'll leave the little test version here just so we can see it actually working and you have a working example of it. I'm going to just build a quick get called api, and I'll just call it sql so we know what it is, in the same pattern we did before, request, response, but in this example, I'm going to go ahead and get some SQL data. So first I'm going to need the msnodesql project, and I can get that by saying require msnodesql. Next I'm just going to create a connection string, and you could store these in somewhere more common, but this is just a quick example. And this is just a regular SQL Server connection string. I'm pointing out an instance of SQL Server Express on my machine, a database and telling it to use a trusted connection. There's nothing really magical in the connection string, you're already used to dealing with connection strings in .NET, this should be pretty comfortable. And then we can simply take our msnodesql and issue a query. We're going to give it a connection string, a query, and then a function callback. And like the other patterns we've seen, it's going to be an error, and then the results being passed back. So if they kind of open the database, it'll give us an error, otherwise it's going to give us the result of our query. Let's go ahead and just write, because this is actually pointing to a Northwind database. We should be able to do SELECT * FROM Customers, and then we can simply say res.send results. And we'll leave the error handling example to you for later, but for now, we'll just go ahead and send the results assuming that this is going to actually work. Let's run this and then over here in Firefox, I'm just going to call this localhost, call API SQL, and when you run this, you're going to run into this so and so isn't a valid Win32 application, and that's because it's trying to use this SQL Server node object as the native driver. This is actually an error you can ignore and this is another one of those that we want to click and then unclick to make sure that we don't see this exception again. I'll just hit F5 to continue, and if we go back over to Firefox, we'll see it did in fact return this data. And in that same way, if we change the query to go ahead and return one customer and refresh it, we'll see we get that one customer. And notice this time it didn't stop at that breakpoint because by clicking and unclicking to stop on that exception, it knows that it is essentially a first chance exception so we can ignore it in the JavaScript debugging. So what we're showing you here about how to get to SQL is that you're going back down to the issuing queries and then doing the work yourself sort of objects. What you're going to get back from this particular driver is going to be arrays of flat objects. So you're still going to have to go through that same work yourself to create composite objects. So if you're getting customers and orders and order details, you may need to serialize them into those complex structures that you may want to deal with. There are some other libraries out there that can help you do this, but not necessarily directly with SQL Server. The interaction with relational stores isn't quite as polished as the interaction with some of the document stores out there. And that's actually where we'll head next. We'll talk about how to use a document store like MongoDB.

No-SQL Data Stores for Node.js

So when we talk about NoSQL datastores, what really are we talking about? We like to think of them as different to relational datastores, and in fact they really are. The way they store their data is really in the sense of a document or a data structure storage. So you're taking hierarchies and storing them inside these datastores, and then you're going to be able to retrieve one or more of these types of objects. Typically you're going to store them together in something akin to a table, but each row in that table is a hierarchy. It could be a flat object of course, but it's much more common to store complete hierarchies there. You can do queries into those hierarchies, but the language to get into those queries aren't SQL-based, and so doing complex queries means you're going to have to learn a new way to do querying. It's important that you don't get bogged down in trying to map everything to what you were thinking as relational and just think of things as hierarchies, and very often that's the right approach. If you think about the classic customer order and order detail, customer would be this sort of tip of that hierarchy, and then it would have collections for orders, and each order would have a collection for their order details. They may not have a collection of the products for each of those order details, that may be a call into a separate logical table that has the products, so you wouldn't be able to necessarily do joins across these different objects. The different datastores support this in a variety of ways. They're really meant to be run in parallel so that you can sort of break them apart and deal with them in more logical ways. One of the problems we typically have in relational stores is how to horizontally scale them out, and the Node SQL datastores attempts to solve this by saying that you can have the same type of data running on multiple machines or in these things called shards, but they may not be the same exact data, and having ways to find the data you're actually looking for is usually built on top of that structure. One of the things that's rather nice about these is they tend to be really simple to deploy. They're dropped in a folder, you run one command to start up the server, you may write another command to get a command line interaction with the server, much like relational databases were 10 or 15 years ago. This approach to being more simple, especially as it relates to deploying it on machines is something that the NoSQL datastores has really embraced. We often talk about the difference between them and a lot of people like to point at some of the features that you're used to using in relational datastores, transactions being some of the bigger ones. Most of the recent NoSQL datastores, like Mongo and Couch, do support transactions, so it doesn't mean that you can't have or you shouldn't have transactions just because you're using these different kinds of datastores. In the world of Node.js, there's a number of these that you could choose from. Mongo is really the big boy out there when it comes to Node.js, lots and lots of implementations are layered on top of MongoDB. But there's CouchDB out there that's a little different from Mongo, there's Neo4j, Cassandra, which is based on Google's big table implementation, there's RavenDB, which is a document database written with .NET and has really good support for both REST and native .NET drivers, and then Redis, which is more of a data structure store than a document store. There's a lot of smaller players out there, so if you don't like these, continue looking trying to find one that best meets your needs. That's one of the benefits here is that you have a lot competition and people driving in some cases some niche players that may be better suited for your particular needs. You may be storing lots of tiny objects instead of a smaller number of large documents. It does require more investigation on your part because in a lot of ways in .NET we've said oh, we're doing a website, let's fire up SQL Server because that feels like the natural way to store everything that is data. This is going to require you to break out of that mental box about everything as a relational datastore. MongoDB is clearly the most popular one out there when it comes to Node.js, and so let's start there and show you how it works. A lot of what we're going to talk about is going to be applicable regardless of which engine you use.

Installing MongoDB

Let's start by installing MongoDB next to our source code. We're going to start by going to mongodb.org, which is where you can get MongoDB. It is an open source document database and you can simply go to downloads to grab it. Depending on what operating system you're on, you have a few different options. I'm going to go ahead and download the 64-bit version on Windows because that's what I'm running on, and I'll go ahead and save this on our desktop as well. And once I download it and open up the ZIP file, we'll see that it contains a top level folder and then a bin directory, and this bin directory is just the guts of what it takes to run MongoDB. There's a lot of .exes here so you can actually look at the individual files and their database and all that sort of thing, but for us, we're just going to copy the entire bin directory. I'm going to go ahead and put it in our project folder. And I'll go ahead and create a folder for MongoDB, though you can put it anywhere, and I'm just going to create the whole project folder here. Let's open up a command line to this folder. And we're first going to need some place to store the data. So I'm just going to create a subdirectory called data for lack of a better word. It just stores the database for this instance in some folder that you specify. And the command we're going to use is mongod, which is the server. If we just press Enter, it's going to fail because it doesn't know where to store the data. So instead, we'll say --dbpath ./data. And now it's actually waiting for us to make requests to it. When installed, it's actually running the data server. You can actually install this as a service on a particular box, or you can run it locally like this. And also, some of the online providers like Azure and Heroku have MongoDB as additional add-on services where you wouldn't have to go through this amount of trouble. So how do we know the service is actually running? One of the things you'll notice is that it says that it's attached to the port 27017, and that is the default port that is listening on to be able to interact with it. There's also a second port called 28017, which is the admin web console. Let's go over to Firefox. If we just go to localhost:27017, which is the web end for interacting with the MongoDB, you'll see that we're trying to access the native driver port, so it's telling us that this is the wrong port to go after. If we add 1000 to that, we can actually see a web front end for it. It's going to tell us some information about the server, including a log of what's been happening since it went up. And one of the commands here is listDatabases, so we can actually see the different databases that it found in the db path, in our case the data folder. When we click on this, it gives us a little warning that says REST is not enabled. So there may be cases where you want to enable the REST endpoint in order to look at some of the stuff, or even write tools against it. So let's do that real quick. I'm just going to stop the server and just add the command ---rest to turn on the REST endpoint. When we do this when we go to that list databases, this is actually going to show us all the different databases that are the machine right now, and local is the only one. This means if we simply go to local and make sure and end it with a slash, it will show us the rows that are stored in that actual database. Now, the local database is akin to the master database of SQL Server if you're familiar with that. It's going to contain some information about the list of databases that are in there and some other stats about it, but because our data is empty right now, there's nothing in here. Later on we'll use this way of looking at our own database that we build in order to see if data was actually stored correctly. For Node.js projects, I normally when I'm working with MongoDB will just copy this into a CMD file so that I can run it pretty easily, or I might install this as a service on my development box so that I know it's always running. There are cases for doing both. I'll go ahead and create this command file and make sure Mongo is running during the rest of this module and pretty much the rest of the course since we're going to be interacting with the database. Now that the database is installed, let's see how we can interact with it from JavaScript.

Accessing the MongoDB Server

Now that we have MongoDB installed, let's go and figure out how to access it. So the first thing we're going to need is a driver for MongoDB. We've actually got a few choices here. Mongoose is probably the most popular of these, and this is a driver that works in the idea of schemas, so you define what individual items look like and it makes it easy to query them. There's some controversy here though because MongoDB doesn't use schemas itself, and this is sort of a layer to add some of that type safety to your objects. Instead of using Mongoose, and there's other courses here in Pluralsight, you'll see here on the bottom of the screen a link to one of them that discuss Mongoose, I'm going to use the MongoDB driver. This is the native driver that just gives you raw access to the database so you can see how I'm interacting with MongoDB at a low level works. So the first thing we're going to need is to use npm to install the driver, and it's called mongodb. Then I'm going to use the ---save so that it gets added to our package.json. And now you can see here we have mongodb installed on our npm packages. So first what I want to do is access the server directly, and I want to do that by centralizing how we access the database itself. So I'm going to create a new file under data called database. This database functionality is going to be used solely inside of the index.js, so it's not going to be something we're going to expose out, but it's something we'll end up using in most of the different calls of the data component that we're building. I'm going to start with a self-executing anonymous function like normal, and I'll just call it database to be simple. And then like we've seen before, I'm going to execute it by saying module.exports, so we're just really aliasing the exports as this database object. What we want to do here is add a member called getDb. And this is going to be a function that our other components are going to call. GetDb is going to pass in a callback function, one that is going to accept an error and then the actual database if it wasn't an error. Before we implement this, we're going to need reference to the MongoDB project. So I'll go ahead and just created mongodb and use request to get mongodb. Outside of getDb in case I need it in some other places, I'm also going to create a mongoUrl variable that's going to contain the path to get at the MongoDB instance, as well as our database. And this is going to consist of mongodb:// just like any other URL, and then the server I'm going after and the port. You probably remember this port from when we installed it that this was the port that we can go after in MongoDB. This last bit after the slash is going to be the name of the database we're going to build. The first time MongoDB sees this database name it's going to build a database for us, so we don't have to implicitly tell it. And this is in essence just a namespace to a section of documents that we want. We could actually be building 2, 3, 4, 10, 20 of these if we want, but in our cases we're going to keep all our data in one place, and that'll be in theBoard database inside of MongoDB. The last thing I'm going to create a variable for is the database itself. Now the reason I'm creating a variable outside of getDb is I want to only construct the database object when I need it. The reason I'm generating this variable outside the getDatabase function is I actually want to be able to pass back the same database object once the first person creates it. So I'll just defer creating it the first time and then I'll pass it back for everyone else who needs it. This is very much like the C# idea of deferring construction. So now we can actually use it inside of our getDb function. Essentially what I'm going to do is I'm going to first test if theDb doesn't exist. And if no one has created it yet, I'm just going to connect to the database, and we'll do that in a minute. If it's already been created, if it's not null, then I'm simply going to call next, null for the error, and then theDb. I'm going to pass that back to the caller immediately, I'm not going to wait for some operation to open it up, I'm going to assume the database is good if we've created it already, which is what you're going to want. MongoDB supports things like connection pooling, and so creating the database once on your server and keeping it open is actually what it prefers to do. You don't want to connect to the database every time you make a call and then reclose it. You're going to defeat connection pooling and you're actually going to slow down your connection to the database by doing that. So now we can go ahead and actually implement getting the database. We do this by using the MongoDB object that we got from the require, and we're going to call MongoClient, which is an object that it exposes, and we're going to call connect. Connect is going to take the URL we specified and then a callback function. This function passes in an error object and then the actual database object in case it was successful. So here it's just a matter of doing some simple tests. If err exists, then we're going to call next with the error, else we're going to call next with no error, and then theDb. And so here we're going to assign theDb. Now we could just pass the database here, but I found it to be good measure to wrap it in an object, and the reason I'm doing this is you may find that later we'll need to add to this object to include additional information. And so this way the db itself is going to be the db we sent, and then this new object we've created will be the object that represents the database. You might find this useful to extend theDb object later with additional parameters as it's created, who created it, what username it was attached to, those sorts of things. I just find it a better pattern to use an object to wrap my db object. So now we've built the code to get the database, and more importantly to reuse the database as necessary. Now we can use this new function in the next step, which is to actually store data in the MongoDB database. Let's do that next.

Writing Data to MongoDB

The next step, now that we can connect to MongoDB is to store some data in it. So I'm going to open up index.js inside of the data folder, and if you remember we have this call to getNoteCategories that just returns some seedData, and we're going to replace this with getting data later from our MongoDB database. What I want to do next is store some data, so I'm going to create a function called seedDatabase, and this function is going to be useful because when this is initially run, we're going to actually go ahead and seed that database. We're going to open up a connection to MongoDB on startup and then take the seedData that we created earlier so that we have a minimum set of data that we're going to be working with, we're not going to start with a clean slate every time. So the first thing I'll need is the database component we just wrote. And with that database component, we can call getDb, which again we just wrote, and we're going to pass in a callback function that has an error and then has the db object itself. Now since this is the first thing coming in, this will actually create that database object, but every other call to getDb will return fairly quickly because it'll be returning the same db object that we create the first time. Here we can test if there's an error, and if there is, there is no callback, so we're just going to write out to the log Failed to seed database. And I'm going to pass the err information so our console will have this information. Later on we might decide to log this to a file or some other place that is useful for us to look, but because this is happening on startup, there isn't any real interaction, we can't tell the website that it's failing, we're just going ahead and log it. If we get the db, what we'd like to do is insert the data, and this data is what we have in the seedData. So let's open seedData to remind you what it looks like. The seedData has an object called initial nodes, which is an array of these category names with individual notes for each of them that we're going to display on the screen later. So before we seed our data, what we're going to want to do is make sure that the database hasn't already been seeded, otherwise we're going to insert the same records in there multiple times and we'll just get duplicates, that's not what we want. So what we'd like to do is test to see if data exists yet, right? So we'd like to be able to test this and we should be able to test it. Normally you would think you might want to do something like db.notes.count equals 0, and that sort of works, but it doesn't, because again, we're doing non-blocking codes and this might assume we're going to go do some count on the server to see whether any data exists. Let's start by creating that notes object and then we'll talk about how to do this count asynchronously. Both those pieces are going to be important. So let's go back to that database.js that we created a minute ago. We created this as an object because we actually are going to want to create another member of it called notes. So the way that MongoDB works is it works with the idea of collections. So inside of a database you might have a collection of certain types of data. You can think of this logically if you're used to working with relational databases as tables, the only difference is you're not going to tell the table what kinds of data is going to be stored because they're individual documents stored in these collections. The way we define these collections is from the db object. We can say db.collection and then give it a well-known name, and in our case that will be the notes collection. This just returns an object that notes how to go after this collection, and the first person who stores data here will actually create the collection. We don't have to do any tests here to see whether note exists or whatever. And this collection creation can be reused. Again, this is where we're getting the benefit of storing the database object that we're creating here so that everybody that requests it gets that same object, we're not waiting for the database to open and then waiting for this collection of notes object to be returned. Now that we have the notes defined as part of our database object, we can come back here and see that the database notes that we created a minute ago will be valid, it's looking at the collection called notes. But this needs to be asynchronous, we can't just check count by checking 0 because this would require a call over to the server and then for something to come back. So of course count is a function and that function takes a callback. So we'll get rid of the if around it because we're not going to do the if there, we're going to do the if in here. So if an error happens, we're again going to write to the console. Otherwise, we'll go ahead and check if count equals 0, means we've never stored anything in it, we can go ahead and do the work of saving the data. How do we do that work? If you remember, we created a seedData up here. Let's go over to it just so you can see what it looks like. The seedData has one member called initialNotes, and these are the documents we actually want to store, the initialNotes is an array of these note objects that contains the name of the collection and then the number of notes for that named collection, or that category as we've been calling it. And we're going to store each of these initial notes with the category name, as well as the hierarchy of the notes themselves as one document inside of MongoDB. So we can simply say seedData.initialNotes, which is the name, and then we can use forEach to walk through them. Now if you've done a lot of web development, you might not be that comfortable with forEach, and that's because you don't know what version of JavaScript you're dealing with. So in the browser, forEach, even though it's available on edge browsers like the latest version of Chrome and Firefox and even IE, you don't know that everyone is going to be using that kind of browser so you tend to drop down into jQuery's each function, writing your own for loop, even using Underscore's each function to handle this. Because we're in Node, we know what version of ECMAScript we're dealing with and we know forEach is available. So we can just use it and it's going to take a callback and is going to be called for each item in that collection. Now we can use that db.notes to insert our new object. Insert is going to take that item we want to insert, which is the callback from the forEach as item, and then a function that tells us whether it succeeded or not. And here we'll just do a quick console.log if it fails, Failed to insert note into database. Because we're calling C database after we've constructed it here, this is going to go ahead and run through and the first time it will insert into that database. So let's go ahead and tell console.log so we can see it in the running of our Node project that we're Seeding the database. And let's go ahead and put a little else here just so we can get some more information and say Database already seeded. So let's run this and see what happens. We're going to see that we're getting that MODULE_NOT_FOUND error again that we ran into before, and this is a specific kind of error for optional modules that may or may not be used. In fact, the MongoDB has an optional module that it can use for Kerberos security, and we're not using it in this particular case so we got this error caught. In later versions of Visual Studio, they'll probably know what kinds of errors to display or not display, but we're going to go ahead and uncheck the break when module not found is run because it's such a common exception. Let's go ahead and close the exception and I'm just going to press F5 to continue past the error. We can see it's seeding the database, and that means it has stored it inside MongoDB. Now we don't have code that is yet reading the database, but we can go ahead and use the admin console to take a look at this. So let's go over to Firefox. I can go ahead and stop this because it's not stopping MongoDB, it's just stopping our Node project. And I'm going to go to localhost:28017, and this is going to be the Mongo admin console. And I'm going to go to listDatabases. Now we can see that there is a local database like we saw earlier, but now theBoard database exists. So if we go to /theBoard, we can see it's now created, but it doesn't have any rows. Under theBoard is going to be each of the collections we created, which in our case is going to be notes, and there are our actual notes. Here's the History notes, here are the People notes. So what is this doing? This is storing into that database the entire document we talked about, and then we're able to retrieve them using this rudimentary admin REST interface as JSON. We're not going to actually use this interface, we're going to use the MongoDB driver to interact with our data, but we can see that the code we wrote is actually inserting into the database so that we can actually use it in our code. And that's what we're going to do next, we're going to read this out and use it to display the same home page for our board project, but this time using MongoDB.

Querying Data in MongoDB

Now let's show you how to retrieve data in MongoDB. We stored it in the last video, we'll be able to get it back in this video. If we go to the top of this index.js inside of our data folder, you'll remember we used to have the getNoteCategories that we used just to return our initial notes from the seedData. We're going to change this by replacing it with getting data from the database. So we're going to start by using that database object and getDb like we did before, testing for err and db so that we're going to go ahead and get the database and when we get the callback, we can go ahead and use that database. And like before, we're going to test for the error, and if the error, we're just going to return next err, null. So if this callback shows an error, we're going to use this next function that was passed in to tell the caller about the error. Otherwise we need to use the db object to get at the data we want to return. We can do that pretty simply. We can call db.notes, again we're using the collection object that we created the first time, and we're going to use the method called find. And in this case by putting nothing in find, we're telling it to find everything, and then we're going to call toArray to turn it into a collection. Now if you've done LINQ inside of .NET, this should be pretty comfortable, this is similar to the ideas around the way that LINQ works. We're going to call toArray, but we're going to use a callback function to get at the actual results. And we'll continue to need to do the same sort of nested testing that we did before. If there wasn't an error, then we can now just pass back those results. Those results are JavaScript objects that represent the data that was stored in the database. So next, null, results. Because we seeded the database and we're replacing this call that we used earlier to show our categories, this should continue to show the two categories we have in the database. Let's run it and see. See the second time we ran this it said the database was already seeded, so it didn't insert them again. And in here in the browser, we're seeing History and People, including the counts that we created in earlier versions, but this time we're actually pulling them from the database itself. Let's go back and look at that find method. This find method actually allows you to specify a few different things like what to look for, and it does this by passing in an object that contains what you're looking for. So if we create a new object with name People, this is going to filter out only the objects that pass this test. Find in many ways is like a where clause in LINQ, we're going to give it an object that should represent the kind of query we're looking for, and we're looking for items in that collection who have a property called name that equals People. Go ahead and run this and see what happens. See we filtered out everything but People, so we're only getting that object. We could also look further down, and if you remember, in the data we have the collection of notes, and we can use a sub-object to define what we want to do with notes. And so let's use a special kind that says size of the notes is going to equal 5. If we run this, we'll now see it's only returning History because History has the number of notes that equals 5. In the same way, we could wrap this yet again and use not to do a reverse comparison, and there's a whole language here for how to do these queries. You could do greater thans and less thans and all sorts of different things, I'll leave that to you reading the docs. But just so you can see, we can now get any objects whose notes sizes is not in this case 5. Now we're getting People because of course the size of the notes collection is 3, not 5. If we take that out, there's another call called sort that works in much the same way that allows you to determine how to sort what is being returned from the find. And in our case, we're going to sort by name and I'm going to say -1 to do in reverse order, so People, the History, and if we change the -1 to a 1, we'll get them in proper alphabetical order, which is the order I'm going to want to leave it, so we'll leave the code like that. But you can get a taste that the API here for looking through collections is going to provide you with a lot of the tools for getting at the data in a LINQ-like way. One of the pieces that might be more uncomfortable for some of the .NET developers out there is you're not going to be able to issue SQL queries, because SQL queries works on sets and MongoDB and the other document databases out there aren't set-based stores, and so SQL doesn't really work, you would have to massage what SQL does into something that would work against hierarchies versus sets, and that's just too difficult to do, just ask the people who created XQuery how easy that is to do. It's not. I find that this syntax is plenty for most the kind of operations I'm going to need. The way that MongoDB works in particular, and I'm not going to show you an example because it can get a little elaborate, is you can actually include JavaScript as part of the queries because inside of MongoDB, there's a JavaScript execution engine. So you can actually write complex queries using JavaScript itself. I'm not sure I would suggest that because it tends to be slow, but for edge cases where you just have to get it some very arcane data, do know that there is sort of a pastor that will allow you to do more interesting and complex things. So let's take what we've seen here and actually show the ability to insert data from user interaction of our website into MongoDB and see how all that works together. We'll do that next.

Inserting Data with a Form

Next we're going to take what we learned with MongoDB and use HTML to insert some data into the form. This is going to be a bit MongoDB and a bit of Node.js put together. Let's start by going and finding our index view, and after our other row, let's go ahead and create a new row and inside of it I'm just going to paste a form. This is an ordinary form using some Bootstrap styling in it, but for the most part it's just a form that's going to post to newCategory with the data that's in here, and it's just a textbox for a category name and then a button to say go do it. If we run this and take a look at our form, we'll see it just adds to the bottom here a way for us to add a new category like Programming and then create the new category. And we'll go ahead and respond to this call and add new categories to the board. Later on we'll go ahead and add new notes to each category, but for now we're just going to add new categories themselves. In order to respond to this form sending us some data, let's go look at the controllers, and then specifically our homeController. And inside here we're going to use app.host instead of get because the form is going to post this data to us, and where is it going to post? It's going post to newCategory. And like before, we're going to take a callback for the request and the response. But in this case we're posting data to Node.js, so we want to be able to get that data. So this is going to be the category name we want to get when it's posted to us. So how do we take the data that's been posted by a form and get at it here inside of the post handler. We can do this by looking at the request and looking at the body. Now the body is going to contain whatever data is being posted to us. In this case it's going to be by default form encoded. Later on, we might build an API that would take it as JSON formatted, but in this example because we didn't do anything special, the form is actually going to post it to us as form encoded data. So the body is going to have properties for each of those form variables. And the form variable we're looking for is categoryName because this input is named that, when we post it it's going to go ahead and post it as the name of the control that we put data in. Express inside of Node.js is going to take each of those names and make them a property of this body object. So let's break here and let's see what's going to happen. Let's refresh our page. We have Programming put in there and when we click it, it's going to take us to this post just like we'd expect, right? The form is posting to newCategory, and then this should have our categoryName in it, but it doesn't. And why doesn't it? The way that Express works is that there's a lot of functionality that's built into certain framework in ASP.NET that just exists, because we're in ISS, because we're using ASP.NET or because we're using one of the flavors of ASP.NET like Web Forms or MVC or Web API. In Express, we have to tell it that we want to use certain subsystems, and reading the bodies or the form encoding is something we have to opt into. So let's open up our server file and do that. I'm going to create a little section up here that says Opt into Services, because we're going to need a number of these as we go on in this course, but the first one we'll need to do is say app.use, and then on express we're going to use a function called urlencoded that's going to return an object that is used by the app engine to handle form-encoded data and attach that to the body. So now that we've opted into the service, let's run it again. We still have that breakpoint, let's go ahead and hit New Category. We should stop here in the post. We can now see the body as an object and that the category name is Programming that we were sent in. Because we opted into using URL encoding, the URL-encoded subsystem, the form we posted, is able to send us that data and then the subsystem is going to break down that form into properties on the body object of the request itself. So now we're ready to take this category and insert it into the database. And let's do that next.

Creating a New Document

Now that we're correctly getting that category name, let's go ahead and use it. We want to insert this new category into the database, so let's use the data subsystem to insert that. So we're going to call a property on the data component that doesn't exist yet. So in this case, I'm just going to stub out that we're going to call createNewCategory, and let's pass it in our categoryName, and then a callback to tell us whether it worked. Inside the callback, let's just test for the error condition, and if there is an error, let's log it to the console just for now, and we'll go ahead and use the response object to redirect back to slash. And we're going to handle the error in a moment, we'll get to that. But let's deal with actually inserting this into the database. If we don't have an error coming back from createNewCategory, what should we do? Let's go ahead and also redirect, but in this case instead of redirecting to the home page, let's assume that when they create a new category, they're probably going to want to add new notes, so let's give them a new whirl, notes plus categoryName. So this is probably the functionality we want. If there's a problem with creating the new category, we'll redirect them to the home and later on we'll show how to feed this back to the user. And if it does work, let's go ahead and send them to the notes page for a specific category. Let's go back to the data component and let's add this new method for creating a new category, createNewCategory just like we called it before inside of the controller, and what are we going to need here, we're going to need the categoryName and then the callback function that we'll callback when we're done. Like the other call we did here to get the database, we're going to need to get the database again and I'll just go ahead and use some editor inheritance here to not have to duplicate that code. So if we get an error of getting the database, we'll go ahead and notify the caller, otherwise we can use the same sort of code we did earlier in inserting a new document into the database. And I'll just call it a category for now because we want to construct the document like the other documents are, and this is where using something that handles the creation based on schemas might be useful, like we briefly talked about in Mongoose, but we're going to do it all ourselves so we can see what's happening. This new category is going to need a name and of course that name is going to be the passed-in categoryName. And then the notes is just going to be an empty array because we haven't added any notes, but we do want to have the property there so that we can go ahead and do things like counts. If we don't include it there and then we're going to test for only documents that have a count of notes, it won't know that that property exists, so it's best to go ahead and create it, but give it a value, like in this case an empty array to do the right thing. So here we can use db.notes, remember that's the collection of notes inside of the MongoDB database and call insert and insert our new category. We'll have a callback to see whether it works, and if error, otherwise we'll return next with nothing in it. So we can see the code here to insert a new object is pretty straightforward. We're creating structured documents and then we're inserting them into the database and just checking to see whether the insert succeeded or not. If we've done everything correctly, our controller code that will be called with this new category should insert the new data using createNewCategory, and then direct us to this new page if it succeeds in calling our new method createNewCategory. Let's see if it works. So let's give it the Programming category, let's press New Category, now it's going to take us to notes/Programming. That assumes that it probably worked, right? But let's check. Let's use the method we did before to actually look inside the database. Let's look at the notes for our board and we can see there's now a Programming category and this Programming category has a property of notes, but the collection of notes is empty because there's no data. This _id that you're going to see at the end of each one is an internal Id that MongoDB uses to determine which object is which. For the most part I wouldn't touch these, and I would just use the properties you're used to dealing with. So we can see now that our code mostly works. We do have a little problem though in that this would allow us to create duplicate categories. So let's next look at how we would look into the database to check for whether a category exists or not and then throw an error if it does.

Testing for Existing Data

In order to check for duplicate category names, there's a couple of approaches. We could go to the controller itself and call data.doesCategoryExist or something like that here. I prefer to keep it inside of this createNewCategory object and just have it be another failure condition. So in this else, before we create the new category, let's go ahead and see if one exists. So db.notes.find, and this is where we're going to use that find syntax, name equals categoryName, and then a callback for error, and then I'll go ahead and use count with a callback just to see whether there is one that exists. I don't need to get the object, and so count will just give me a more simple count of objects in the database that match our query here of categoryName. And I'll go ahead and wrap this inside of our callback and let's go ahead and check for error. And if there isn't an error, we're also going to want to check if count does not equal 0, then we're going to want to do something, right? We'll want to return an error, otherwise go ahead and do the right thing here, make sure we have enough matching nested ifs. So the count doesn't equal 0, it does exist, so we can just say next has a back as a string, null result. Actually we don't need the second parameter like we've been sending it in here, I'll go ahead and clean that up real quick. So we're going to say that there's an error, Category already exists, and then our code should continue to work. Let's go ahead and run this. And if we go back over to our home page, we can see that we now have the three categories except that of course programming is empty. And if I put Programming in, create New Category, it's just going to return us back, because it actually returned an error. Let's look at the log. So we can see it showed Category already exists in the console. The reason it did this is that when we called createNewCategory with this duplicate name, it went and looked in the database and it found that this category name already exists. Because it already exists, we called back with this error, Category already exists, and then the controller went ahead and logged it to the console. But this isn't going to be good enough because the redirect doesn't show this to the user, we need to feed this back to the user somehow. Let's do that next.

Handling Errors

As we saw in the last video, we can capture errors that are written out to the console, but there's no way currently we can expose this back to the user, which we're probably going to need to. So in the case of creating a new category, there's no way to tell the user that what they typed in was a duplicate category. So let's go ahead and make that happen. What we're going to use to do that is something called connect-flash. So if we go out to the command line, and I'm just going to say npm install connect-flash. And I'll go ahead and save it so it's part of our project and that's all that's required. And we can see connect-flash is now part of the npm stack. And what connect-flash allows us to do is actually use the request, there'll be a new function called flash on our request, and here we can give it the name of some temporary message. In this case I'll call it our newCatName, and then here I'm going to actually show the error itself. So when we find an error, we're going to tell it hey, store this temporary error information for us because we're about to do something like redirect, and when we redirect back to this index view, we're going to take that flash back out. What we'll do is let's break this up into separate lines so we can see it a little better. So we're going to add another member to the object that we're sending to the index view, and here I'll call it the newCatError, and I'll get it back out by asking the req.flash, and that same name we used down here. Because this function passes two parameters, it knows we want to set it, and because this is including one parameter, it knows we want to get it back. So you may be curious about how this actually works. This works by taking the information we're storing here in the flash early in the call, and storing it in session for that particular user. And then when we call flash a second time to retrieve it, it not only gets it and returns it to us, it removes it from session. So this is a very temporary way of storing information and error information is a common way to do that. Now currently flash isn't going to be included because we have to opt into it. We've included the npm, but we haven't actually told the server we want to use it. So we're going to start out by adding an instance to the flash library by using require, just like we've done most other things. We're going to require connect-flash and this is going to return to us a flash object that we can use here when we opt into services, app.use flash, execute the required object, and this is going to return something that's going to support flash. But like I said, flash uses session state, and by default, Node and Express don't use session state. So we're going to have to use that as well. Express.session, and the session takes an object to configure itself, and this object can take a secret. The secret is what the session state is actually encrypted with so that only people looking at this instance via your JavaScript code will be able to decrypt that session data. So I'm just going to give a magic name here like PluralsightTheBoard. And string will do. The way that session works in order to tie it to an individual browser session out there, is it uses cookies to track sessions for individual users. So we're going to have to opt into that functionality as well. And that's called the cookieParser. So in order to use flash, we're going to need to use all three of these different services. The first two were part of Express, and then flash we got from connect-flash. So let's go ahead and open up that index view because even though we are now storing the information as part of the model that we're sending down to the index view, we're not doing anything with it. So on top of the new category here, I'm just going to add a new if model.newCatError. So if there is a good object that it was able to retrieve from flash, let's go ahead and put in some code. So here we're going to inject the newCatError and a paragraph tag, we're going to use Bootstrap to color it a little, and we'll show the newCatError if it exists. So most times this won't take up any space, but if we have an error, we'll go ahead and show it. Let's see what this looks like. So we're back at The Board. And I'll go ahead and add a duplicate category name like Programming. I click it and it shows Category already exists. Now let's walk through the code once again so you can see what's actually happening. So the homeController gets called here with newCategory from that form. And one of the things that the data.createNewCategory function does, let's go down into here, is it attempts to see whether the category already exists. We can see it's getting a count of things with that same category name, and if the count does not equal 0, it actually returns Category already exists as an error. Back here in the homeController, this error is going to be valid, and so we end up shoving it into flash and telling the browser to redirect to the home page. The browser goes oh, you want to redirect to the home page and restore it, then our route here for the root page or the index view gets called and as we're rendering our index view, we're going to pull out what we shoved in flash a minute ago and pass it to the view as part of the newCatError. And of course this gets rendered in the view itself using the Vash markup. There's a few moving pieces here that are interesting, but what I want you to concentrate on is that this is a decent way to send back error information as you're going from page to page. But it's also useful for sending any sort of messages or errors that you need to communicate as you're moving, especially through redirects. This flash functionality of being able to set it once and then go ahead and pulling it off the stack when you need to use it the first time and that it won't exist after that is exactly what it was really built for.

Summary

So to wrap up this module, let's talk about what we've learned in Node.js as far as accessing data is concerned. We've seen that when accessing data and storing data in particular, we're going to have to give up strong typing. This is very much the same as most JavaScript we're going to be dealing with, this JavaScript happens to just be on the server. Well many examples of Node.js out there use NoSQL datastores, you don't have to, you can still use relational data like SQL Server and MySQL. While you can access SQL Server with the number of different drivers that are out there, not all options are easy or full-featured. So you want to be careful about the driver you pick if you're going to use Node.js to interact with existing SQL Server implementations. We spent a lot of the time discussing MongoDB, because this is a very common solution when you're working with Node.js. You've seen that the setup of MongoDB is pretty straightforward, it just involves a single directory of executables. Running your own MongoDB server or even multiple instances of a server on a single machine is very simple. You've also seen the very basic core MongoDB driver, but there's a number of drivers out there that add functionality on top of it that can simplify your code, Mongo being the most common of these. While working with the basic MongodDB driver, hopefully you've seen how collections are really the way to store data in MongoDB. These collections are much like tables in relational datastores. While you won't be able to use your existing SQL knowledge to query the database, querying MongoDB is much like querying with something like LINQ from .NET. You're able to use the same sort of patterns that you're probably already using with Entity Framework in order to get at data inside of the MongoDB server. This has been Accessing Data with Node.js. My name is Shawn Wildermuth with Wilder Minds. Thanks.

Building an API with Node.js

Introduction

In this next module we're going to build an API with Node.js. We're going to start off by talking about what is an HTTP API. We'll start out by comparing Node with ASP.NET ASMX services. Then we'll talk about comparing it with WCF, ASP.NET MVC, ASP.NET Web API, and then we'll dive into the actual implementation with API controllers, GET actions, and POST actions. Let's get started.

What is an HTTP API?

Let's start out by talking about what an HTTP API really is. When we talk about HTTP APIs, we're really talking about things that are RESTful APIs, things that are soap-based, things that are based on what some people call Web APIs, essentially operations that are going to come over HTTP or HTTPS, port 80 or port 443. It doesn't matter whether it's SOAP or REST, but typically it's going to be XML or JSON formatted. It doesn't have to be, it could be binary and some other things, but very typically we're talking about APIs that are either using SOAP or REST. Each of the calls to an API include the description of what a message is, and messaging should be the concept you're really looking at. So the full message description is going to include things like the body of the message, especially as it relates to SOAP, header as it's going to relate to how to handle an operation, and methods. So taking the same call using a GET verb versus a POST verb versus a PATCH or a PUT or a DELETE or an OPTIONS, they're all going to be part of what we think of as the call to an API. It's also typically built on standards, so we don't want to reinvent the mechanism for communicating. This means we're reliant on JSON and XML and WS-Security and SOAP and REST to really define how we're going to be building these APIs. So essentially when we talk about APIs in this particular module, we're talking about making requests over a web port in order to execute an operation, and the information about that operation is going to be in the form of a message, a message that might include bodies and headers and methods, even in some cases cookies, and that those messages and those ways we're calling the server are all built on standards. So let's compare what we can do in Node.js to some of the ways you can write APIs or services using existing .NET technologies.

Comparing .NET and Node.js for APIs

So let's start out by talking about ASMX services. If you're coming to Node.js from the world of ASP.NET Web Forms, it's pretty common that you're going to write your services with ASMX services. ASMX services are SOAP-based, and Node doesn't support SOAP, and I'm not sure you should either. We're really talking about REST-like APIs. Now they don't have to conform completely to REST, some people refer to those as RESTful or HTTP APIs, but we're not talking about building SOAP client and SOAP envelopes and all the other things that go with SOAP, you're going to have to think about writing your APIs in a different way if you're already using it with ASMX services, and we'll show you how. One of the reasons for this is that ASMX services attempt to hide what is actually happening. You build C# or VB code that accepts certain types of .NET objects and then returns some type of .NET objects, and it tries to hide all of those details from you. In node you're going to be aware of those details, and working with those details isn't difficult, but it is going to be a mental mind shift that the framework isn't going to quite do as much for you as you're probably used to in ASMX. In this way, Node.js in cooperation with Express will give you the view of what the service is actually doing, it's much closer to the metal than ASMX is. It also means that any sort of client can call it, you don't have to worry about what is on the other side of the wire if they can consume your SOAP endpoint like you do in ASMX, you know that pretty much any sort of thing out there, WinForms, Web Forms, ASP.NET of really any flavor, IOS, Windows Phone, Windows 8, Android, any sort of client you have out there will be able to communicate with the Node.js APIs. It does apply some basic services to you like the idea that you have JavaScript objects and it's going to convert them into JSON for you. JSON is a format that looks a lot like JavaScript, but is more for structured objects in JavaScript. And for the most part, you're not going to have to worry about converting to and from JSON, that's going to be done for you. You must still understand how headers on these calls work, how verbs work, and how bodies work, and so how to take information from the body of a message, how to send back the correct headers and the correct status codes, and you must understand when you're building this what sort of verbs and what those verbs should do. If you're returning data, then using a GET, if you're creating a new entity using POST, if you're making a change to an entity using PUT or PATCH. Those sorts of things you're going to have to understand, and in some ways they're outside of the scope of this course. Unlike ASMX, the idea of how security works is just simply layered on top of what you're going to do with writing these services. It's not magical like sometimes forms authentication is in ASP.NET. You're going to be aware of how security works and you're going to see how it works, and when it fails, you'll be able to get a better handle on what it's actually doing. If you're coming to Node.js from the WCF world, you're going to have a different sort of view of what it's trying to do. You have to deal a lot with configuration to get WCF working correctly. It wants to separate the idea of transport from interface so that you're defining these services and then could use them over a variety of different transports. So you might have it over HTTP and SOAP, you might also have the same service that's going to go over pipes or network connections, and even serialize in different ways, and so a lot like ASMX, WCF is trying to hide some of the gory details of what happens on the wire. When you're talking about APIs in Node.js and Express, it's all about the HTTP or HTTPS transports, we're not talking about exposing them in a different way. There is an exception to this when we talk about WebSockets at the end of this course, but for the most part when we're talking about building APIs or talking about building APIs specifically in an HTTP manner so that they can be consumed by JavaScript some place or other endpoints that can accept things like JSON. There is some middleware out there that can expose some other transports, but that isn't what you should be focusing on. Most the time you're going to be building a back-end that's going to service a front-end. Very commonly that front-end is going to be a website, but it also could be mobile apps, it could be embedded apps, it could be even desktop apps. The big difference between WCF and the way that Node does this is there's little to no configuration. So you're going to be writing the endpoints that you want to listen for and then respond to directly. You're not going to be trying to mapping some arbitrary set of classes or interfaces to the endpoint that some system is listening for. This means that you're going to be responsible for handling a lot of the stack, but later when we start to build this, you'll see that this is pretty thin. We were always worried about being isolated from a lot of these details, but in fact a lot of the details were just muddling the picture and making things like debugging more difficult. WCF does try to get away from its SOAP roots by introducing the idea of using REST over attributes, but honestly this is just lipstick on a pig. The way that WCF does REST is one more layer of indirection, is one more abstraction that just makes it harder to configure WCF to be consumed over a different kind of client. If you're coming here from MVC, you're actually a little closer to the way Node does things than either WCF or ASMX services do. MVC can let you create your own APIs by changing the way you return data by telling it that you're going to be returning XML or JSON data and you can create something that looks and feels like an API. MVC by default is really geared towards GETs, but you can use other verbs by using attributes. And so a lot of people have had success in building APIs using MVC. Node.js and Express assumes that you're going to understand the notion of how making calls into an HTTP service are going to utilize verbs, so the verbs are going to be part of that message to determine what that message really means. For example if you're doing a post, it's going to assume that that post is going to contain a body that needs to be inserted into some datastore, whereas if you're doing a put or a patch, it assumes that you're going to be including data that needs to be updated in the datastore, or if you're doing a delete that you want it removed from the datastore. Even though the body of those three messages can look alike, that verb ends up being pretty important in Node and Express. And this is pretty similar to the way MVC handles HTTP verbs. Remember MVC was built as a layout engine, and so get is the default behavior because it expects that you're going to be calling in to a controller and the result of that is going to be markup, and so the razor markup, much like the Vash engine we're using here in Node is turned towards putting out HTML. It can be sort of bent to creating APIs, but it really wasn't how it was envisioned to. In many ways, I consider it the wrong tool for building APIs. In that same way, MVCs route tables are a distraction, they're one more place to configure to try to bind the call that's coming in to some arbitrary piece of code, and in the case of MVC that is a controller. This can be laudable in MVC because you have the sense of discovery of controllers by what the client is using as a route, but the Node.js model is different from this because it's simply tying the route next to the code that's implementing it. So we may call them controllers, but it may not be controllers in that strictest sense. I like the simplicity of knowing that this specific route is going to be handled by this specific piece of code. And the last of the comparisons is with Web API. Web API is the newest member of this group in ASP.NET, and in fact, most closely resembles the way Node handles APIs. What I mean by this is that the verbs are really obvious in controllers in both cases. So in the case of Web API, if you're doing a get on a specific controller, the method is called get, you're not trying to map it with attributes or any of those sorts of things, the methods that match the verbs are simply matched by convention, and that's a little of the same way that Node.js and Express does the same action. This means that you're given a little bit more freedom in Node.js and Express to structure your code. If you want to call them and structure them into large controllers, if you want to put them together in the idea of routes or route tables or you just want to have arbitrary functions out there that handle individual cases, you can do any of these, you have a lot of freedom in how you structure your code, though I tend to still stick to the idea of building controllers that all do the same sort of operations on a similar set of functionality. Unlike Web API, the controller base class is not required, or in the case of Web API the API controller base class. In Web API 1.0, it has the similar mechanism that MVC has in that it's using routing tables to discover what controllers map to individual URIs that are coming into the server. In Web API 2, they expanded on this by adding attributes so you could have the routes as close to the implementation as possible, and in Node.js and Express, this is much closer to the Web API 2, the route itself is married to the handler. When we tell it that we want to handle a GET for this individual URI, the next piece is the actual handler for that code, it's one single unit whereas in Web API, you can still separate it. So, enough talk. We talked about kind of how they're different and how they're similar, but I think it'll make the most sense once you see it in action. So let's go build a controller and add some functionality to that controller.

Creating a Controller

So let's start by creating a controller object. Here we're back in our TheBoard project, and inside the controllers folder, I'm just going to create a new controller that I'm going to just call my notesController. This is going to be a set of code that's going to be responsible for the different API operations I want on the notes. Now I don't have to call this controller, there's no convention that is looking for this name or any of those things you might be familiar with both in ASP.NET or JavaScript libraries like Angular, it's simply going to be a JavaScript class that's going to contain this object that we're going to call the controller. And I'm going to start with a self-executing anonymous function that's going to take the controller itself in as a parameter, and then like we've done before, I'm going to pass in the export so that this is really just an aliasing of that export into something that makes this a little bit more readable. Next we're going to tell our notesController that we want to include on it a call called init. Init will be a function that passes in the app object. This app object should look familiar because it's the same way we actually built the homeController. Here's the homeController, we're passing in the app, and then we could do app.get and app.post and those sorts of things on it. So what we want to do now that we have the controller, we'll go ahead and add our routes and handlers in a few minutes, but let's open up the index.js and add this as something to be wired up when the controller's component, this directory full of different components, is executed. First we need to require the notesController, and then we can just say notesController.init app, just to continue, so this is going to add into the Express app all the routes that we're going to need in this case for the notes API controller. And now we're ready over here to actually write our first API endpoint. Let's do that next.

Creating a GET Action

Next, let's create an API endpoint that returns some data. Back here in that notesController, let's go ahead and use the app object to do a GET, and it is simply a GET, right? The fact that it's an API call isn't anything special. What we're returning is what really indicates whether it's an API call or not. Earlier we used get to be able to do things like get the homepage or to get the notes page, right? We're going to do that same thing here, but we're going to start it with api/notes/, and then we want to be able to get the category name. We can do that by using a parameter here that I'm going to call categoryName. The path we're giving it is telling it that we want all of this to be static, but then we want what is after those two pieces to use that as a parameter, so this could be anything. And then if that's called, here is the handler for it, request and response. Again, just like we did when we built the pages, we were using res.render to go ahead and use that Vash engine, but we're not going to use render here because render is for a returning HTML. So we could certainly here, especially if we had some static data, we could call send and then send back some arbitrary object. In the engine itself, unless otherwise told, we'll format this as JSON for us. It takes this object graph and returns it back as raw JSON. If we're good citizens, we'll go ahead and set, which is how you set headers to things like Content-Type application/json. But for us we're going to actually need some data. So here inside of our notesController, we're going to go ahead and use require to get at that data component that we've been using to getting data. And we're going to want to call getNotes, which will be a new function we'll write in a minute. And here we want to include that categoryName because we want to get the notes for a particular category and then have some callback that's going to give us either an error or the notes. And I'll go ahead and wrap our little example around here, but we haven't yet shown you how to get at this category. For every label that's here inside the route, Node.js and Express will add it to the request object. So I can say categoryName = req.params, they're the parameters passed into the route.categoryName. So it'll literally pull this out of the parameters. Now you might say well what if one wasn't supplied? If one wasn't supplied, then this callback is never called because it doesn't match this route, there may be another route that it matches with, but in our case that's just the route. And so here instead of sending in that arbitrary object, we're just going to return actually the notes that are passed into us. These notes are already a set of JavaScript objects so that when we send them back as notes, they will be JSON serialized for us. So if error, what should we do here? We're actually going to use that send again, but here we can pass back the status code we want. If we don't include a status code, it assumes it is 200 or OK, but in our case, a, 400 we had a problem, and what is the problem, I'll go ahead and send err as the body of that message. So if we get an error, we'll not only get the failed, we'll get how it failed. So it might be that we want to put a static string in here, or in this case just pass back the error itself. Now depending on the sort of operation, you're going to need to decide and understand what the status codes mean. So if this was an error, you're not going to send back 302 or 401 or 404, but you might send back a 404 if the category name wasn't found, which we don't have really defined here, but the nature of the way we're using this it should be fine. Your job as a developer is probably to bullet proof some of this later, but as a teaching tool hopefully the minimum here makes sense. Now we need to go ahead and just implement that getNotes really quickly. So over in the data component I'm just going to create the getNotes as a new function, and I'll include the categoryName and then that callback will be passed in so that we can call back to them whether there's an error or not. The first thing we'll want to do is go ahead and get an instance of that database object, and I'll do some editor inheritance here to make this a little simpler. So it's going to get the database object, if there was a problem, it goes ahead and returns the error. If not, we can actually call the notes collection, remember that is part of the database object, and there's a method on it called findOne. FindOne says go find the first instance of this. This is very similar to the first or default method on a LINQ query, but here we're going to include the query information, which will be name equals the categoryName that was passed in. And here we'll give it a callback, err and notes object. Now we could certainly do this and handle the callback, but remember that this pattern here for this function callback is identical to what we're passing into getNotes. So instead of that, I can actually just pass in next so that when findOne finishes in either an error its successful condition, it will simply call the callback that was passed into us. So understand that you don't always have to deal with the callback and then execute next on your own, there may be times when what you're asking for as the callback here is in fact the same signatures you're expecting in the sort of bottom part of your business logic here. And so I'll just call next, the findOne, it'll either return an error if it couldn't find it or it will return those particular notes. So let's run this project and let's switch over to Firefox and just go to that, api/notes, and in this case I'll pick History as that category name. And we can see it retrieved that data from the server and we're returning that entire object. We might decide that instead of that what we really want to do in the notesController is send back not the notes themselves with the category name attached, but actually the notes property on that return data. You can see here that the object we're returning back, which is that entire notes object includes the name of the category, which we already know because it's here in the URL. We may just want to return this object, this array of notes in order to show them in the UI. So we'll do that be calling notes. We run this again and refresh that same call, we'll see we're now just getting an array of note objects that represent the data we want to show in the browser. This is all in preparation for us to actually writing a richer page for the individual notes. If you're using Firefox or Chrome or one of the other browsers to test this, be aware that not all browsers are going to deal with JSON as a display type all this well. I'm actually using an add-in called JSONView in Firefox to make this a little easier to see so things can be collapsed. So if you want the same experience I'm getting and you're using Firefox, go ahead and download and install the extension for Firefox called JSONView. Now let's switch up gears a little and figure out how to create a post. Someone wants to add a new note to a collection, how do we do that?

Creating a POST Action

So let's create a post action. We're going to add a new route and handler here for pushing a new note into the server and then have us injecting it or inserting it into the MongoDB database. So how do we do this? We can call app, but instead of calling get because get is when we want to return data, we're instead going to use post, which is just the same name as the HTTP verb for the same operation. And our URL is going to be the same. We're going to say post to notes categoryName, and if someone posts to the same URI, then we should be able to take the JSON object they sent us and insert it into the MongoDB database. So the callback is going to be the same, it's going to be request, response, and we'll be getting the categoryName in the same way as well. So just like before, it's going to be in the parameters named by this variable in the URI. And again like before we're going to want to go ahead and stub out the functionality of the call to the data component, in this case it's going to be addNote. What we want to do for adding notes is give it a categoryName so it knows which category to add this note to, and then we're going to want to give it a noteToInsert object, and I'll show you what we're going to do there in a minute, and then we'll have a callback of the same pattern, but we'll just accept err, we'll assume that if there wasn't an error that is actually inserted correctly. There may be reasons to get back out that newly inserted piece from the database in order to get its correct internal Id and things, but for our needs, we're just going to assume if it succeeded we can tell the user it succeeded. So let's create that noteToInsert. What we want is simply a new object, and this new object is going to represent the note that was typed, the color of the note that was chosen, and also the author, which in this case I'm just going to hardcode. We're going to come back when we do security and we'll be able to know what author inserted this because of the way security works so that the client doesn't have to send us the author. Now if this were a certain kind of API, we might be able to just take the data that was passed to us and use it as this note to insert, but in this case I'm going to construct a different object that has maybe fewer, or in this case more properties than the object that was passed to us. So you'll notice I just put empty strings here, but we can actually get at the pieces of data there were passed into this post, because the idea of using this as a posted object is that the request is going to contain a property called body, and that body is going to have properties for those individual pieces. We've actually seen this before. If we look at the homeController, when we created a new category, we were able to look at the req.body and get that categoryName from the form variables that were posted to it. In this case we were doing a post directly from a form, what we're doing here is a little different, is we're allowing them to post directly to us some arbitrary data, usually in the form of JSON. So here the body will have a property called note and we'll have a property called color. So I'm going to set a breakpoint here when we grab the categoryName so we can look at a couple of things at runtime. But when we run this, we're going to need to be able to test to this post, and that involves using one of a number of different kinds of tools out there. I'm going to use one called Fiddler. Let's take a look and see how that works.

Testing a POST Action

So now that we've started to build this post action, let's go ahead and test it. I'm going to run the Visual Studio project, so we can wait for this breakpoint to be called when we actually post to this URL. I'm going to use a tool called Fiddler. This is a free tool you can get. Telerik is actually the maintainers of Fiddler now, but it's a free web debugger, and if you haven't used it before, I have a course that talks about Fiddler in depth if you want to see some more of the big pieces, but I'll show you the highlights for what we want to do. Fiddler allows us to construct using this Composer tab an exact call to our code. So let's do something we've seen in the browser before, which is like localhost:3000. So if we just go after that root page on our Node.js project, when we execute it, it's going to come back with a 200 and under Inspectors we're going to be able to see that the raw view of what it returned, we're going to be able to see on the bottom here what was returned, and if we look at that raw view, we can see it was just the XML that was produced by our Vash. So in essence what we're looking at is being able to compose certain types of calls to our web server. In this case Node.js. For us to test puts through, we're going to use this Composer tab to compose a post to our server. This is something the browsers have a really hard time doing unless you're going to write your own sort of HTML page that mimics some of this, or your own JavaScript code. I'll change the verb to POST and then I'm going to give it that path of api/notes/, and let's say History. So this is the URL, this is going to map to that call we're going to do, but we also want to tell it what content we're sending it. So I'm going to say Content-Type is going to be application/json. And this is going to tell Express, hey this is JSON, try to convert it back into JavaScript objects when you call me. So I've created a small piece of JSON, and JSON again looks like the object syntax inside of JavaScript, but that the property names have to be quoted, and that's the big difference. There's some other smaller differences, but when you're creating simple sample versions of JSON, that is the big change there is that all property identifiers have to be quoted. And if we execute this, it'll actually stop here in our post, so we can run and debug this. If we look at the parameter names, and this is just an array, we'll see that categoryName is there as History. Perfect, just what we want. And in fact if we look at the request object in the body, the body exists, but we're actually in for a rude surprise, and that is that even though we included note and color as parts of the body, they're being undefined because it couldn't determine from the body how to convert this request body into this body object, it had no idea how to do this. And the reason for this may be obvious to you. If we go back down to the server.js, you'll remember that we opt into certain services, and in order to get the forms working in a prior module, we had to tell it that we were going to accept urlencoded bodies. That's how we got the form to work. Well, if we're going to use JSON encoded bodies, we actually have to do the same thing, we have to opt into JSON simply by adding it to the services that our application is going to use. So let's rerun it, and we come back over and execute this again, it should take us back here, and again categoryName is fine, but now we can see that the note and the color, in fact the whole body object is going to contain the same properties that we passed in as JSON. So now we know what to do with this. We can generate our new noteToInsert that has those pieces of information that we care about, note, color, and author. And now we're ready to go ahead and insert them into the database using this new call called addNote. Let's do that next.

Saving Data in an API Call

Now that the post is working, let's go ahead and show you how to save data and what to return from posts as as example of building a rich API. So when we call to addNote we're expecting it to return us an error if it doesn't work. So we're going to implement addNote, but let's talk about what happens on an error or not an error condition. This is going to be similar to what we did on the get, so we can say if there is an err then we can simply res.send 400 Failed to add note to data store. But if it succeeds, we're going to first want to set the Content-Type to application/json so that it knows what kind of content we're sending back. And then we want to send a 201, 201 is a status code that means created. This is specific to posts. It's saying everything's okay, but we also created a new object usually in some sort of datastore, and I'm going to give you back that object, which is going to be the noteToInsert. So what's interesting about this is that we're giving it back essentially the same data as it passed us. So why do we bother sending it back? We send it back specifically because we may change the information. In fact, that's what we did. We took the note in color that was sent to us and we added to it who wrote the note. And so assuming the addNote had been implemented, we now have this working in the way we want it to. Again, the code here isn't all that complex, there isn't a lot of business logic here, and you can see mostly what it's trying to do. Let's go ahead and implement the addNote functionality. So I'm going to go over to the index of data and add a new method, data.addNote. And matching the signature we had before, this is going to be the categoryName to add it to, the noteToInsert into the database, and then the callback for when it's complete. And like before, we're going to need that common code that gets the database and returns an error if it finds one. So if no error happens, then we can actually use the database. In here we can say db.notes to get at the collection of notes, but instead of inserting it, this is one of the ideas you have to get your head around with document databases like MongoDB is that we're actually taking an individual document, and that is the category in notes, we're going to insert some objects into that existing document into Mongo, and we do that with a call called update. So even though this is logically an insert, a creation of new entity, this is actually creation of a new object that is inside of an existing object. So we're going to update the database even though logically from the API's perspective, we're actually inserting a new object. So update as the first parameter takes a query object that says what object do you want to update, and in our case that's going to be the name that has our categoryName in it. Now if you remember a few minutes ago when we were looking for notes, we use that same syntax, find one of categoryName, right? We're going to do the same thing with the update, go find our named category and what do we want to do to it? We want to push into the note collection our new noteToInsert. So it's going to take this new note and insert it as one of the array that is note inside of the document that is for our categoryName. And it's going to take a callback that is just an error. Now much like we did before, I'm just going to actually pass in that next, because all it can do is pass us back an error at this point. And so we'll go ahead and use the callback that was passed to us as the chain of command back to the API code. So here in Firefox, let's go to the note for The Board. And this is a little hard to see, even though this is returning JSON, the browser doesn't know the data type here, so it's a little unclear on how to display it. But we can see we have the name of History and it has a number of notes, Testing history, I like history, et cetera. We also can see some empty ones down here like programming and gaming. Let's go ahead and add it to the Gaming note so we can see it. So let's start our project, and over in Fiddler I'm going to change this to the Gaming category of notes. And I'll leave the request body and let's go ahead and execute it. And we've come into where the breakpoint is, I'll get rid of that, and back in Fiddler we'll see we got a 201. That means it successfully created it as far as we were concerned. And if we look at the body that was returned, we can see it actually returned us the correct JSON for that object, a note, the color blue, and then the author that we had amended it with. Well this all works, our code could work here, but it might be obvious that it's in the database, so let's check here in the raw view of the data on the server, and we can now see that for the gaming object we now have a note. The note includes this first note that we just inserted. So if we go back to the root of the website, we'll now see that Gaming has one member. So in this brief way we've shown you a fairly simple way to implement APIs using get and post, so this is going to apply to the other verbs like put and delete and patch as well. And it can also relate to more complex routes like association route. So you should have the basis now to build your own APIs using the techniques I've been able to show you. Let's wrap up this module.

Summary

So we've shown you how to build an API with Node.js. You should have seen that mostly when we're talking about these APIs, we're talking about APIs over the web, RESTful, REST-like APIs, APIs that are using JSON and port 80 or port 443 to communicate, these are the kinds of APIs we're talking about. If you're coming from the ASP.NET ASMX world where SOAP is the popular way to build these APIs, Node is going to allow you to do this, but in a quite different way, and so it's going to require changing your mindset to an HTTP-based API versus the abstractions you're going to get from SOAP-based APIs. If you're coming from the WCF world, you'll probably be pleasantly surprised at the lack of configuration and some of the configuration over convention problems you have in WCF. Of course if you're coming here from MVC, you're going to see that the protocol is going to be more in your face in Node.js and Express than it is in MVC. MVC of course is built around some amounts of ceremony to tie routes and controllers and the handlers for those controllers, and even the markup for those in a different way. Node is different in that it's not treating APIs any differently whether they're going to be doing page routing for normal controllers or something like API controllers, every route and handler for that route are pretty coupled together. And if you've already used Web API, the simplicity of Node.js and Express should be pretty familiar. The idea that it's using the same name of methods to define handlers for get, post, put, delete, patch, et cetera should be pretty comfortable if you've already built any code using ASP.NET Web API. In Node.js and Express, we're given more freedom, so we can describe these containers for actions as controllers or routes or whatever you really want. It allows you to structure your code in ways that make more sense in your domain. Now if you're more comfortable because of where you're coming from, feel free to call them like we have in the examples here, controllers. It's not wrong, it's just a different sort of mind set, you're really defining a bundle of handlers for specific routes. They don't necessarily have to be defined in anything like a class. In fact, they are wired on after another. The fact that we're sort of artificially putting them in to the initialization call that is being called by the component itself is the bit of ceremony that allows it to be tied together and to be componentized in a way that makes your code a little bit more readable. So ultimately you're going to be taking the verbs you're interested in and the areas of the work, like whether it's the API or whether it's pages or whether it's some part of the API like security, and you're going to be putting them in these containers and then handling those individual verbs next to that action. There's a mirroring of the two inside of the way that Express and Node.js work together. Thanks for joining me for Building an API with Node.js. My name is Shawn Wildermuth of Wilder Minds.

Using Angular.js with Node.js

Introduction

In this next module, we'll talk about using AngularJS with Node.js. We'll start off with a brief introduction of AngularJS, then I'll show you how to add it to your project, how to create a module, how to create a view, how to create a controller, how to use the API we created in the previous module by calling a get method, we'll create a form, and then use that form to post some data through the API we created in the last module. Let's get started.

What is Angular.js?

So what exactly is AngularJS? Unlike most of the other work we've talked about in this course, AngularJS is about client-side script, or JavaScript that's going to be run inside the web browser. It's a client-side framework for creating these richer experiences on the web, whether those are single page applications or simply complex pages that follow the MVVM, MVP, MVC model. AngularJS is a bundle of features that will help you implement these richer web experiences. I like to think about AngularJS as being a comprehensive client-side web framework in that it takes a lot of the different features that web developers were required to cobble together in order to build a comprehensive web project. These include things like data binding, dependency management, networking, routing, mocking and test of your code, and then being able to extend that framework itself. If you're coming from ASP.NET, you may be comfortable with client-side JavaScript or you may be uncomfortable with it. If you're writing most of your applications using classic Web Forms or even classic ASP, you'll be very used to doing most of the work on the server, so every time the user interacts with your application, it's going to send data back to the server for you to do something with, and then re-render the page. If you've been using other technologies like ASP.NET MVC or Web API, you're probably already used to having some amount of code in the client. Angular is a rich framework for doing that, and allows you to build comprehensive, highly interactive web pages. Let's take our Node application as we've been using it, and building a new interactive page for our notes, allowing you just to not only read notes, but add new notes to the page.

Mocking the Notes Page

We're going to start off here by mocking up the UI and tying together our server-side view with our new Vash view. Much like ASP.NET, we've got this views folder and so far we really just have a single view called index. So we're going to go ahead and create a new view by adding a text file called notes.vash. This will be a view that will contain a single category's notes. We're going to allow the user to go ahead and view the existing notes and add new notes. We're not going to go as far as to allow them to edit or delete them, we're just going to allow them to add it. So we can go over to the index.vash. What we really want is the extend for layout and then the block for body so that we know we're creating a new view. And so our view at this point could simply be something as simple as Hello World, but for us we want to do something different. Instead we're going to start with a little structure, and I'm just going to paste it in and just show you that we're starting with a div that contains a Back button link. This is going to be an anchor tag that's going to take us back to the home page. And then we'll have another div embedded in here that we're going to add some content to in a minute. Again we're using standard HTML, there's nothing magical about the HTML we want to use here in order to just build up this new notes page. Next we're going to build the individual notes, the look and feel of the notes, but before we do that, we're going to need some assets. So I'm going to go over to the public folder and create a new folder. This folder is going to be called images, because in our particular design, we have a look and feel for post-it notes for each of those notes. And I'm going to add an existing item, and in fact I'm going to add a number of new items, and those will be found in your examples folder called resources. And so just select all of the PNGs here and they'll be added to our images folder. Now I'm adding them to the public images because we're going to use them in our client-side HTML as what an individual note looks like, and you'll notice that we have four different kinds of post-it notes. Now that we have the images, we can simply create a new note, and I'm going to paste in a little structure we have here that is the note. This note includes the class for note that describes what it looks like, and then a note-yellow that tells it which of those images to use. So we're doing all the real look and feel for our individual note with CSS and images. Then inside we have a div that indicates the content of the note, and then a small other div that contains the information about who wrote the note. And I'm going to make a couple of copies of this so we can just sort of mock it up, and I'll just come here and change this to a couple of different colors using the class so that we can see three different notes. Now that we have the HTML marked up, we have to have a way to actually get to these notes. Let's start by opening up that index.vash and we'll remember that we have a forEach in our vash markup, or our razor-like syntax where we list each of the kinds of categories. But at the beginning of that is an href that indicates where it goes, and we just put a placeholder of a pound character in there, we want to replace this so we're going to go to the note. We can do this by simply indicating hrefs. So how are we going to do this? We're going to say notes and then @category.name. And this is going to allow the user when they select one of these notes, they'll take them to the note page. So finally we have to take a look at this format, this structure of the URI, and answer it in some way. And we'll do that inside of the controllers. If we go back to the homeController, we can simply add a new add.get, notes, and I'm going to use a parameter here called categoryName. Now this is no different than what we were doing in the API in the previous module, so we can go ahead and get the categoryName from the req.params.categoryName, and then we can simply call res.render. In this case we're going to look for the notes view and we're going to pass it in the title of our categoryName. Now that we have bound the route for the note categoryName, we need to do one more thing before we can test this. If we go ahead and open up our site.css, you'll notice that all it has is a declaration for the body, it does not have any information here about how to display those notes. So if you're in Visual Studio, you can actually use Edit, Insert File as Text, or you can open this file manually and copy and paste it if you're using another editor. But the file we're looking for is inside of that resources folder that's inside your demo called notes.css. This is all the CSS for the notes themselves. This is going to bring in a new font from Google fonts, and then include the CSS for both the note and the different color of notes, as well as some special styling for the author itself. Now that we're including that in the site CSS, we should be able to test this by going ahead and running it. And now that we're here at the home page, we can see that when we hover over each of these different items, that it's going to show us that route we created, notes/ the name of the category, Gaming, History, People, and the Programming. And if we click it, it will take us over to our new view, and the new view has the three notes that we had created with some sample text in them. It also has that Back button that will surprise, surprise, take us back here. And notice that because it's in the layout that the category name that we're passing down as title is being handled by the layout, the master page if you will or the layout file for your design. All we're doing is creating the code that does this section, right? Here's that Back button that we created and then the three notes that we're using as samples. Next let's bring in some client libraries to make this actually work and look at real data.

Adding Angular.js to Project

Next, let's add AngularJS to the project using the Bower tool we saw earlier. So I'm going to create a new command prompt in our folder structure, and if you remember, we have this .bowerrc file that indicates where we want Bower dependencies. And so I can say bower install, and I'm going to use the name of a project that's called angular-bootstrap. Now angular-bootstrap is going to include AngularJS, the latest version, as well as UI Bootstrap, which is a special set of controls that we will use later to create Bootstrap-specific controls that can be used with Angular. You'll see how that works as we get through this module. So here we can see it installed 1.2.15 of Angular itself, as well as the angular-bootstrap, which is 0.10.0. And for us, the primary thing we need to worry about is that version of Angular, because that's going to be most of what our client code is made of. Before we can use it though, we're going to need to add it to our layout. So let's open up our layout and let's go down to the bottom, and if you remember, this is where we included jQuery and Bootstrap and Underscore. And we'll just go ahead and add to that because now under the public folder we show all files, we'll see that lib folder that now includes angular. So I will go ahead and grab angular.min, and don't forget to fix the linking because in this version of the Visual Studio Node.js tooling, there's still some problems with it fixing some of these paths for you. We're also probably going to want to use the angular-bootstrap, which includes the ui-bootstrap library. We will use that later, so let's go ahead and add both of them. One of the interesting things for us is that we may actually want to include other scripts, and certain views may want to include certain scripts. We can actually do this. If we looked up here at how we're dictating where the body goes on our layout, we can really use that same functionality, html.block, and I'll call that scripts. Now while I'm at it, I'm going to go up to the top and do the same with a styles, I'm actually going to call it with a head section, so that in some cases we may need to include a CSS sheet at one point on the page, and then one or more scripts at some other part of the page. And I'm including these blocks in pretty specific places. In the case of scripts, I want all of the scripts that are page or view-specific to be loaded after all the standard libraries, or as anything that's in the head, which is normally going to be CSS sheets, I want that to happen actually before our site.css. This is usually because I want to have the ability to add specific library CSS in necessary on a page, but also use our site.css to override those values. So I want our site.css to be the last style sheet loaded in all cases. Now that we've brought this into the project, let's go ahead and write some of our own client-side code.

Creating the Module

So the first step in using AngularJS in our client-side code is to create an AngularJS module. So let's do that. I'm going to start by creating a new folder in our public area, and I'm going to call it js, and that's going to be where our JavaScript lives. None of these names are terribly important, you could use scripts if you prefer or scr or whatever you want to use, I've gotten into the habit of using js for JavaScript files, just like you've seen css for CSS files. And now I want to add a new file, and this is going to be for our notes view, so I'm going to call it the notesView.js. And I'll just put the name at the top so we know what it is, and just like the server-side JavaScript files, I'm going to use that same functionality of creating a self- executing anonymous function here. The difference here is that instead of passing in the alias to module.exports, I'm just going to load these directly and let Angular do some of the dependency management for me. But in order to create this first module and really a controller, which we'll also want here, I'm going to pass in angular, which is hanging off the window object. And I'm just going to call it angular up here. Now you don't really need to do this, angular would probably work inside of the scope on the client-side, but I've gotten into the habit of avoiding the lookup by being specific about the angular object I want to pass in, and then within the scope of this self-executing anonymous function, I'm always doing the right thing in using a local object. And now to create the module, I'm simply going to call angular.module and give it a name, and in our case that'll be the notesView module, and then give it an empty set of ray brackets to indicate there are no other dependencies. We may add some later, but when you're creating the module, this little piece of code is not optional. The module is where you're going to start when you're dealing with Angular. Now I'm going to breeze by a lot of the concepts in Angular because they're covered really well in the Pluralsight library. In fact on the bottom of the screen you'll see a couple of links to some courses that I recommend if you want to learn Angular in depth. So we're going to implement our client-side code here using Angular, but Angular in a pretty simple way. We're going to need a module that's going to contain all of our code, and that we're going to tie up into the view, and then we're going to need a controller that will go ahead and control our page. The module we see here is really a unit of work that relates to some part of a page, and in our case it's going to relate to a single view. You may have other modules you create that are used as dependencies for different modules you write, but I'm going to focus on creating this module that's going to handle the client-side code and only the client-side code. This is very similar to the way that you would create classes in .NET or the way we created server-side modules using the module.exports functionality. Of course in our server-side code, we were using require to pull it in. In our case, we could use a library like require.js or one of the similar type libraries, but because our example is fairly simple, I'm just going to include this on the page using that new scripts block that we defined in the last video. So if I go ahead and open our notes, you'll notice that there is a block for the body, just like you might expect, but I'm going to add a new block here saying this is going to be for the scripts. And its callback will take in that same model even though we're actually not going to use it. In here we can grab our new notes view and again fix the path as the script that's going to be injected into the bottom of the layout. Just to refresh your memory, because we said this is going to be the scripts block, anything inside here will be rendered in our layout here where we defined the scripts block itself. It will inject this onto the page. Now that we've created the module, we can start to work out an implement our client-side data binding directly inside of the HTML, and we'll do that next.

Creating the Client-side View

Now we'll take that module we created in the last video and use it to define our client-side view. And we'll also introduce the concept of data binding and what that looks like in a simple case. So if we open up our notes view, we're going to see that we have this div here that represents the entire section of code that this view is going to be dealing with. And that's an important concept here. We're going to want to think about this section of pages being what is logically our client-side view. The way that AngularJS ties these together is it allows us to specify that some module is going to be responsible for this section of code, and it does this by using its own attributes that all start with ng-. And inside of this ng-app attribute, we can simply give it the name of the module that we want to use, and where does this name come from? It comes from the name of the module you specified here. So what we're effectively telling the view here is that when it loads up and Angular loads up, Angular waits for the entire page to be loaded, and then it goes and looks for these attributes. If it finds an ng-app attribute, it knows it needs to go find the module that was created by the angular.module call, instantiate it, and start the process of serving this JavaScript to be used for this section of HTML that we have dictated here. This does mean you can have more than one ng-app on a page, you can have different parts of the page, have different responsibilities. Now depending on what version of Visual Studio or other editors you're using, you may not like this ng-app attribute because it doesn't actually adhere to the HTML5 standard. It is a custom attribute name, and you can't just extend that attribute names willy nilly. But there is a special prefix that HTML5 has said if you use this prefix, we're going to ignore all the attributes that start with that. For our example here, I'm going to omit using the data-prefix to make our code a little bit cleaner and to see that all the attributes that AngularJS is going to dictate that we're going to use are going to start with ng-. The next attribute we're going to use is one called ng-controller. Ng-controller is the idea of having some piece of code that is responsible for handling interactions with the user, both pushing data into the view and pulling data out of the view, as well as handling things like button clicks and link clicks and those sorts of things for a particular section of the page. We're only going to have a single controller in this case, but you could see how in a complex page you might have a controller whose responsibility is for one section or pane of a particular page, and that's really the concept here. So I'm going to create a controller name here called notesViewController. And you can call it whatever you want, using the full name with controller on the end is a style that lots of Angular wraps use, but it's not required. In the next video we're going to build this controller, but let's talk about some of the data binding that we can actually get to happen here. And this is one of the early strengths of AngularJS is the ability to use data binding directly in the markup here so you can build up dynamic pages pretty quickly. The first thing I'm going to do is actually get rid of the extra mocked up notes. I'm getting rid of all but one because I want to specify that we want this whole section to be repeated for every note that we find in a particular category. We can do that with an attribute called ng-repeat. And ng-repeat takes a forEach pattern in it. So in our case I'll call it the n in notes. So this assumes that the controller has a property called notes that is going to contain the list of notes and that for every item in this collection, it's going to repeat this entire section of markup and allow us to use this temporary variable called n to represent an individual entity in that. So this is very much like a forEach loop in JavaScript or other languages like C# in that you're specifying a new local variable that is going to contain each instance as it's iterated over. So let's see what this looks like. Instead of the note text being mocked up here, we can actually use AngularJS data binding. AngularJS data binding uses a double curly syntax to say if it's inside double curly braces like this, then we know this is going to be a data binding expression of some sort. And in our case, we can use this n that was defined in the repeat as local variable of sorts and just call the property on whatever those objects are, and in our case it's going to be the node itself. We can do this same thing here with our author, and notice that this doesn't have to take up the entire body of a tag. I have some other nested tags here, as well as a prefix of a little dash before it, and that's all fine, you don't have to use string concatenation or anything weird there. And there's even some special data binding attributes that you can use, and we'll actually use one called ng-class. This is going to allow us to add a class to this div. And the reason we want to do this is instead of specifying the color here, of course the note itself has a color associated with it, so we should be able to do something like note- + n.color. Notice that this syntax is going to allow us to imbed little bits of JavaScript into our data binding as well. We're not just talking about putting in the color as the class, but because our CSS classes start with note-, and then the name of the color, we can simply use string concatenation to put that all together. These are just a few of the basic data binding sort of structures that Angular has, and its data binding stack is fairly robust and complete. You'll actually see as we walk through this that we're going to see data binding for forms and data binding for showing and hiding elements, et cetera. So the magic of Angular in this case is to allow us to take some data that we're going to retrieve in the next couple videos and simply data binding here, especially as it relates to something like an ng-repeat where you can create collections of items really very quickly. Now that we've specified the view, we're going to want to go ahead and create that controller so we can see how data binding actually works. Let's do that next.

Creating the Controller

Now that we've created the view, let's create the controller for that view. If we go back to the notesView, we can create a controller by calling theModule. So it's going to be an object that the module will have access to, and you call it by calling the controller function. You're going to give it a name, and this name is going to match the controller name we used here. The next parameter is an array, and this array is going to take as strings the objects we want injected into the controller. So the only one we're going to need at first is one called scope. And each of these strings is going to represent an object that we need inside of our controller, and the last member of this array is always going to be the controller function itself. And I like to keep the function on a separate line. Because we defined our needing a scope here, we're also going to need that variable name inside the function itself. Now you may be curious why we need to specify the scope as a string here, and then again as a variable name here. And the reason is minification. If you're not going to minify your projects, you can actually simplify this by having the second parameter of the call to the controller be just the function with the methods. The problem is when we minify this project, the name of this input parameter is going to be minified, it's going to be probably converted into a single character name. The way that Angular injects it into the controller is by name. And so once this name has been changed in the minification, it doesn't know what to inject into the controller. Therefore we use this array construct to list the injectable objects first so that it will survive minification. The scope represents the section of our view and is a property bag for the different pieces of data we're going to bind against. In many ways you can think of the scope as the view model if you've done any MVVM implementations in XAML or WPF, in Windows 8 WPF and Silverlight, et cetera. It's the object that exposes the data to the view. So when we talk about the scope, this scope is actually the same scope as the hierarchy of the controller. So our scope here is going to represent this entire div and everything inside of it. So if we simply create on the scope a new property called notes, we can have this as a collection for our data binding to go through. Remember, we said n in notes, this notes property here is actually being looked for on the scope object. So let's go ahead and mock up a couple of notes so we can see this actually work. And let's give it a color of yellow and an author of, we'll put my name because some days I think I'm that interesting. And let's make a couple of copies of this and let's just change their colors and we'll just change the name of the notes so we can actually see this work. So all we've done at this point is defined a property on scope called notes that we're going to use with the data binding syntax we did in the last video. And if we run this and we refresh, we should see that data we just put in, yellow, blue, green, Hello World, Hello World Again, and Hello World Finally. We're seeing the same elements being bound now. If we go back and create a fourth one, and refresh our page, we'll see the fifth one show up. This is a very important concept in JavaScript is that the pages themselves are going to react to changes to the objects on the scope, so our job inside of the controller is to manipulate that collection that the data binding is going to react to. So in fact we're going to start with an empty array with no objects in it, and none of these will show up. In fact, let me show you that. So with just an empty collection, the whole div disappears, and it isn't until we actually add to that collection that it will attempt to try to start binding these separate objects for us using that ng-repeat attribute. So the next step would be to use the API call we created in the last module and go and get the notes for this specific category we're in. And we can do that next.

Calling the API

Next we'll call the API we created in the last module inside of our new controller. So we're going to start by getting rid of all those sample notes we had a minute ago, and we first need to get the category name, right? We're going to eventually go to our API and pull out all the notes for a category, but we need to figure out the category name. One way we can do this is to actually look at the URL itself. If you remember, the URL here contains the name of the category we're looking at. So we could use the window object here to look at the location, which is going to contain the information about that URL, but the problem with that is we use the base window object, we're not really going to be able to test this later because the window object may not have good information for us when we're running tests. So Angular tries to deal with that by giving you objects that represent standard objects you may use like window, allow you to inject them in, and then later when you run tests, those objects can be mocked up pretty easily. So here we're going to include another injected object. In this case we're going to call it $window. Now you may notice a pattern already. These variable names that start with dollar sign are ones that are provided by Angular. So if you see dollar sign so and so, you know that's a reserved name for Angular. If you see double dollar sign, that's a reserved private name for Angular. So in both those cases, you should avoid using dollar sign or double dollar sign as your own variable names. And this is a special object that Angular is going to pass in that actually represents the same interface as the standard window object. So to get the category name, we're first going to go ahead and get the urlParts. We can get this by going to that window object we're now passing in and looking at the location and then splitting the path by slashes. So this is going to give us an array of strings for each element in the location path name. And then we can just get the categoryName by looking at the urlParts and grabbing the last one, since it's zero-based we're using -1 to make sure we're getting the last one. Now that we have the categoryName, we'd like to be able to go and put together a URL that represents getting the notes from our API. If we look at our notesController where our API lives, we might remember that it's api/notes/:categoryName. So if we start with api/notes/, and then add our categoryName, we should have the right URL to go get our resources for the notes for a particular category. But how do we do that? Do we bring in jQuery and use its AJAX functions, do we find a third party library? In fact, Angular has one built in called HTTP. So we're going to include another injected resource called http, and in this case it uses a very simple API that's actually a lot like the way that Node.js and Express work. We're simply going to issue a request called get, give it the notesUrl. Now instead of passing in a callback, AngularJS uses a concept called Promises. If you haven't used JavaScript Promises before, let me talk you through it pretty quickly. The idea is to be able to chain several calls together. And so in our case we can call a method on the returned object from get that has a function called then. And then takes one or two functions. The first function is what happens when it is a success. The second function is what happens when there is an error. And I'll just say TODO on the error, but for our success, this will be called in when our operation is successful. So in our case we can actually set here what notes we get from the server. Since we're in the success, we can take that result and just assign the data to the notes. This data is going to represent that list of notes for this particular category. Again, we should handle this at some point. We could certainly do something simple today like show the err by alert, but you're going to want to do something a little bit more sophisticated later. So let's go ahead and run this. And now when I go to a particular category, I'm going to get all the notes for that particular category. Of course even if the category has no elements, it's still going to take us here. So this data binding has really allowed us to use our API in an effective way to show the different elements on our page and to be able to wrap our code into JavaScript components that really work together. And so now that we have individual categories displaying our notes, let's go ahead and take it one step further and allow users to add their own notes.

Creating a Form to Add a Note

Next, let's create the form for adding new notes to our categories. If we go back to our notes view, let's make some space right after our individual notes are shown, and let's create a new section of code for a small form. I can certainly create the form by hand if I wanted to, but I'm going to use a little prebuilt piece that I have in a text file in our resources folder called notes-form. This form is just a pretty standard form, it's using Bootstrap 3 conventions for making the form look and feel the way we want, and we're going to ask for a few different things. We're going to ask for the color of the new note, and then we're going to ask for the content of the new note. For the color we're going to give them four buttons, they are going to be formatted as a button group, and that way they can simply pick the color of the note they want. And then down here, we're going to have a text area that will be the actual note that they can type in. And we're using a couple of attributes to specify that the node itself is required and that it can only be 120 characters long. We're going to let HTML help us in that way. So we run this just so you can see the form, even though it's not really working yet, and we can now see our form down here using the Bootstrap style. There's our Save button, there's Yellow, Blue, Green, and Orange, and we can actually select them. Let's use AngularJS to go ahead and data bind these. First in the client-side controller, we're going to want a new property called scope.newNote, and let's just give it an object that's going to represent some default values, like note is going to be an empty string, and color, let's make it yellow. Then in the form, instead of using this standard double curly brace bracket data binding, we're going to need to use something called ng-model. The data binding we've seen up to now is really one-way binding. It's going to take some value and push it into our controls for us. What we're going to want to do is come down to our text area and let's add ng-model, and this is going to be newNote, because remember that we just added that property called newNote, and we're going to use the dot syntax to save .note. The model for this input is going to be newNote.note. So as the text area changes, the data on the scope will actually change at the same time. Let's do the same thing for these radio buttons. Here we're going to say the ng-model is newNote.color, and let's copy it to all of them. Since this is a button group, it's going to act like a radio button so that as each button is pressed, the value of the radio button here will be pushed into the color. Now these will push the values into our newNote object, but let's introduce another kind of data binding we haven't seen before, which is a logical data binding. So here we can use ng-disabled, and then use some qualifier here to say why should it be disabled, and it will be disabled if our form name, which we can see up here is in our form called newNoteForm, has a property called invalid. Now why would something be invalid. It's invalid because of these validation attributes that are part of HTML5. Before this will work though, because we're using some specific Bootstrap controls like the button group, we are going to need to come back to our module and include the ui.bootstrap dependency in our module. And this is required because we're actually going to be using some components in it, in that our button group here when we're data binding against it requires this extra library. If we weren't using any special Bootstrap control like the button group, we wouldn't necessarily need that, but you can see that in many cases you might have additional components that you're going to need to include in your module. AngularJS is built this way on purpose so that as we build different services or components or different pieces of our logical library, we can include them or not include them in different modules as necessary. This formerly empty array is now going to be the list of required modules to include when we're building this module. So if we go ahead and test this, we can see now that our data binding is actually working, we can see that the yellow is depressed by default when we get started because that was the default color we had picked. And that Save is disabled because our model isn't valid yet, but as soon as we add a character, we can see it becomes enabled because we told the text area that this value on our form is required. In fact we also told it to use a maximum length of 120, so the save isn't going to become unrequired. If we have anything on the browser, it's just going to stop, not let the user type any additional characters. If we erase the note, the Save becomes disabled yet again because it's monitoring what is that value and whether the form is in fact able to be saved. Now we're back in the code, let me go ahead and stop it. We need to make a couple more changes here to show you some of the Angular pieces because we have these required and maximum length attributes, but we're not doing an adequate job to show the user that's what is required. We can show the user that this is a required element by just adding a span after the text area. And this span is going to show required. We're going to use a special attribute from Angular called ng-show, so it's going to say show this span if this is true. And we're going to go into the newNoteForm, which that is the name of the form itself, we're going to look at the note object on the form. Now this isn't on the scope, this is on the form itself, newNote.note because that is the name of the text area. And we're going to see if there's an error object that has been added to it by Angular, and whether the property on that error is that it is an error in whether something is required or not. Let's run this real quick and when we refresh, we can now see that it says Required down here, but as soon as we type into that, that Required disappears. And that's the behavior that in many cases you're going to want. You're going to want some element that's on the page that's going to disappear once that requirement has been fulfilled, and in our case that the content field is required. In our case, we also have a maximum number of characters, so I'd like to be able to give the user an indication of how close they're coming to that. And so we can do that by using standard double curly braces, and then using some simple JavaScript data binding. We can say 120 minus the newNote.note.length. The new note is on the scope, it has a property called note that as they type into the text area that is being changed, therefore we can test for its length and show them that number. Now we can see it says Required, and then as we type, it's showing us how many characters we have left. So this should inform you that you can use data binding in a variety of different ways inside your Angular views. In this case we're doing ng-show to show data validation errors, we're using ng-disable to prevent the Save button from being pressed if the form isn't valid, we're using simple data binding to do things like showing them how many characters they have left and they're typing. All of this is fairly straightforward once you understand how data binding in Angular works, and you can get a lot accomplished without having to go down the road of manipulating your own DOM elements. So now let's implement the pushing of the new note to the server.

Calling the API to Create a Note

For the last step in our interactive page, let's go ahead and use AngularJS to call our API, post new notes on the page, and then show those notes after they've been added. We're going to start by looking at the form we created already, and even though we've got the interaction working so that we can add data, we can pick the color, we can type in the note that we want to include, and we even included some validation, we want to actually be able to save this to the server. So we're going to start by adding a new Angular property here called ng-submit. Ng-submit is an Angular attribute that's going to allow us to say this is what happens when this form is submitted. Now we could certainly have done this down here in the input and done an ng-click and gotten a similar experience, but doing it on the form means that regardless of how the form was submitted, whether it was through code or whether it was through someone clicking on that button that this ng-submit would be fired. Now what do we want to put in here? We want to tell it what to do, and in our case that is call a save function. Now we put the parentheses in here because it's going to execute this like a function on our scope, and we could include state here if we wanted to. In our case there is no state when we call that save. Let's go back to the controller and add this functionality. We've added properties like notes and newNote, as well as some code like go immediately execute and get the notes from the server. So down here we'll go ahead and add a new type of object to scope called save that is a function. So much like we could have added any sort of data to our scope, we can add functions as well that we can call, much like we are doing here on submit. So inside the save function, we want to actually use that $http object again, but in this case we're going to post it. So we're going to take some data we have and push it up to the server. If you remember, we created a notesUrl here that represented the URL to the note category. And this is going to be the same URL we're going to post to. So notesUrl is where we want to post it, and then we have to have some data to post to it. And in fact we already have that data, because we'll find out that as we use the model directives over here in the view, like ng-model here and ng-model here, we were telling it that as the property changed to push it into this new object so that by the time we want to save it, this new note is an object that contains the data that the user specified. So we can simply say scope.newNote. Like the get earlier, we're going to use the promise that's returned to handle two conditions, success and failure. For the failure, we're just going to go ahead and put a TODO for us to implement later, but for the success, we're going to want to think about what we do. There's a couple of different operations for what we want here. The first is to go to our notes on the scope and push the result that was sent back to us. So the result includes information about the post, but the result.data is the data that was returned to us by the API we created. And if you remember in the API, let's open that up real quick, in our post we generated a new note to insert, and then after we added the note to the database, we sent it as the body of our result. So here that data is going to represent a new note. Now you might wonder why not just use this note, why use the data that we're being passed back. The reason is pretty simple. The data that is going to be passed back is going to have more information in it than the note we're passing in, because the note we're passing in is going to include the color and the note itself, but the server is going to have additional information. Right now all the additional information is the name of the author who wrote it, but later on it might be the date the note was created, the date it expires, all sorts of information that may have been generated on the server. So we want to take the result of that push and put it into our screen. The other thing we'd like to do is clear the note so that if someone wants to add another new note immediately, that that form clears for us. And the best way to do this is actually to clear out the note itself to back to the default. When we create the new note initially, we have this little object syntax that we're using as the beginning point. Now I could certainly copy this down there and all would be good, but as a developer that makes me feel dirty. So I'm going to cut it for a moment and create a new function called createBlankNote. And I'll go ahead and just create this named function, there's several ways we could handle this, but this should be good enough. And I'll just return that same empty note. That way not only are we going to create the blank note here, down here after the save, after we've pushed the new note into the collection, we can just call that same function to reset our new note with these values and then the data binding for the form will go ahead and clear those up for us. So let's see if this works. So let's go to the People tab, we've got already some people. There's our form, let's make it an orange, and you just put a note about somebody and press Save. When we did that, it went out to the server, posted that new data there, we got back the object so we pushed it into the collection, and pushing it into the collection told Angular to go ahead and add a new element because of that ng-repeat attribute we saw earlier. We also cleared the form so that we can go ahead and add yet another one. And we can see that just continues. Now you might think, are these just going to be limited to the updates directly from the server. If we go back, we can now see that People no longer has three, but now has five elements, and when we click there we're going to get all five in the same order as we had them, because even though we're updating the screen based on these new elements, part of that process of pushing them to the server is forcing them to be saved into our MongoDB database, which is what we're using to read these elements when we populate the page. So we've now got a rich page that we can go ahead and add, and we'll get that feedback back from the server in order to show the user the new notes. While this isn't a complete AngularJS implementation, there's a lot of pieces that Angular has in it that we're not touching at all that should give you a taste of how you can use Angular in relation to using it with Node as well. You're writing the client-side piece that's calling the server piece, and the code should be very fairly similar. The kinds of object you're creating on the server should be similar to the ones on the client. Let's wrap up this module.

Summary

So in summary, you've seen how to create a user interface using simple HTML techniques when you're interacting with Node.js. The client-side of the story in Node.js isn't really any different than any other technology. So if you're coming from ASP.NET, you're going to be building the same sort of client-side code, markup, and styling that you would with any web project. Because they're using the same sort of technologies, JavaScript mostly, you should get comfortable with the idea that Node.js and AngularJS are complementary technologies. Node.js doesn't require AngularJS at all, and in fact if you're more comfortable with another set of client-side technologies, you want to use jQuery, you want to use Backbone, you want to use Knockout, it doesn't matter, Node.js doesn't make a preference about what client-side libraries you're using, it only has a preference towards how you're building your server-side libraries. Angular does make it easy to build modules, controllers, views, so that you're using a lot of the same kinds of techniques on the client-side that you're now using on the server side with Node.js. There's not as much of a disconnect between the code you're writing on the server and the code you're writing on the client. And in fact, there's some opportunity for sharing that code. When you're writing client-side code, a big different between Node and what you can do in a library like AngularJS is you still need to be concerned about cross-browser compatibility. Client-side code is still going to run within a variety of different web browsers, therefore you need to deal with the fact of lowest common denominator sort of web browsers of fallback or shim strategies for these browsers. There's nothing different in Node that magically makes that better. One thing you probably noticed as we were going through the AngularJS is the way it does dependency management is different than the way Node.js does dependency management. So this means that if you do share code, you're going to have to find a common way to do it. Right now the way the browsers are working, there isn't that compatibility with the way Node.js works with the require or the module exports, but that may be coming in future browsers. And because you can use common libraries on both sides on the server and the client, you can have a single set of skills so that creating your applications can become more similar. For example, if you were using Underscore on the server to manipulate collections, you could use those same shared skills on the client to manipulate collections. This single set of skills means that there's less disconnect between the guys that write up the server code and the guys that write the client code. And in fact in some cases, those can be the same people. This has been Using AngularJS with Node.js. My name is Shawn Wildermuth of Wilder Minds. Thanks for joining me.

Securing Node.js

Introduction

In our next module, we're going to be talking about Securing Node.js websites. To start off, we'll talk about what the Express pipeline looks like. We'll then introduce you to Passport, a plugin library for Express that supports a number of different kinds of authentication. Then we'll implement a registration page, we'll secure our passwords, then we'll introduce Passport into our code, we'll implement the login, and then we'll authorize some pages and some API endpoints. Let's get started.

Express.js Pipeline Explained

When we talk about securing Node, we're talking about accepting some set of credentials and then applying authorization to different parts of our web project. Now in ASP.NET, they've always had systems for doing this. In Web Forms there was a standard forms authentication, as well as systems for a profile and roles that you could opt in to. In more recent versions of ASP.NET MVC, they have a system called system.identity that will allow you to do much the same thing, but within the context of claims instead of simple things like roles. We're not going to dive as far deep into figuring out who has authorization for what, but we are going to show you how to build a simple registration and login page using this middleware that can be used with Express called Passport. But before we do that, we need to understand the nature of the Express pipeline. We've sort of hinted at it in the work we've done before now, but security is a place where it becomes very evident in how it works. Node.js and Express in particular supports this notion called middleware. In ASP.NET we haven't really talked about it in the notion of middleware, but it's a term that's pretty common in Node. In ASP.NET, we think about this as the ASP.NET pipeline, and in ASP.NET MVC or Web API, we think of them as filters. It's simply a way as the request comes in to visit some code on the request as it comes in to be fulfilled or as it's leaving after it has been fulfilled. In Node and Express, this works because Express has middleware that's included by default. So the implicit ones are query, and this is the one that looks at the querystring and breaks it apart into a property bag so that you can look at the querystring at runtime. Once that middleware has been executed, it goes into the expressinit. And this is the location where Express can do its own initialization. This is where things like the Express header is included in every request. And as we use app.use, other middleware is being included. So, in our code earlier on, we actually said express.static to tell it a static directory. That's put into this stack of things to get visited before a request is fulfilled, and in this case, if it is a static file in the file system, it sees that it's part of this path and returns it without having to go all the way down the chain, and so that's one of the reasons a static handler is earlier in the cycle. Next we used urlencoded to look at forms data that was being passed to us and turn it into a set of properties on the request. And so that's handled after the static handler because this is the order we used app.use. If we wanted these handled in different orders, we could certainly have done this. CookieParser is the same way, it looks at the cookies and brings them and extends that request object with the cookie information. Same with session, same with flash, which we're using for messages, same for JSON, so it's taking JSON bodies and converting them into objects, and then the first time we use an app.get, an app.post, an app.put, an app.delete, the first time we use one of these, the router object is being added. Now the router object is the thing that sees the path we're looking for and attempts to match one of those app.get, post, puts, deletes, et cetera. So the way this actually works is pretty simple, and we'll see this in our example later. Before we get to that router, we're going to inject the Passport handler so that's in the middle of this call so that we can do things like check to see if the user has already been logged in and include them as a user object in the request, or conversely on the way out, we could use it to annotate different security information or save security information. And so one of the important ideas because of the stack of the way this pipeline works in Express is that you're going to want your security information to be before that router gets added. So the order of these app.uses ends up being somewhat important. Know a lot of these that you see here on the page don't have to be in any particular order. The JSON and the urlencoded aren't going to conflict with each other because they're not going to see urlencoded bodies and JSON bodies in the same request, but the order of these will matter in certain circumstances like they will in our example when we're trying to secure your web application.

What is Passport?

You have a lot of choices out there for security middleware. A passport is the one I've seen used most, and is the one I'm going to show you in our example. Now when we say Passport we're not talking about Microsoft's passport authentication scheme, it has nothing to do with Microsoft in fact. Microsoft has renamed theirs from passport to just the Microsoft account. So when you see Passport, don't get too concerned that it has anything to do with the passport mechanism from Microsoft, it doesn't, it's simply authentication middleware. So Passport is pluggable. It supports a number of different authentication schemes including username and password, or local authentication as they call it, Facebook, Google, Microsoft, Twitter, those other sorts of authentication schemes, and really any arbitrary OAuth implementation is actually workable with Passport. And it also has a facility for authenticating APIs as well. Let's show you how this is done by starting with the registration page.

Creating a Register Page

So let's start by creating a registration page. First thing we'll start off with is creating a new view for registration, and I'm going to add an existing item. If you have access to the source code, you're going to have a folder called resources, and I have a prebuilt view called register.vash. Now I'm going to walk you through it really briefly, there's nothing special I'm doing in here that you can't replicate yourself if you don't have access to the source code. But if you do, it's simply a form that has just an input for name, an input for email, an input for username, and input for password, and then a submit, as well as a link over to a yet to be written login page. The nature of this is that we're using Bootstrap 3 to style it, but it could be any form that has those different elements, name, email, username, and password. Those are the pieces I'm looking for in a registration page. Now that we have the registration page, we need to have a way to get to it. And the way we'll do this is to open up that layout.vash page and go down to our menu. These are the nav elements and we have a little nav for going home. I'm going to copy this twice and just create one for register and then create another one for login. And later on we'll probably change this to hide these if they're already registered, but for now this should be a good start. We want to encapsulate all of the pieces of security into a single component because we're going to be exposing some parts of the API that we're going to need from different parts of our code base. So I'm going to go ahead and create a new directory for our component, I'm going to call it auth. Then I'll Add a New Item, and like before we'll just have an index.js and we'll just create a self-executing anonymous function like before. And part of the functionality here is going to be initializing the authentication system, including adding the support for Passport and for username and password authentication. So I'm going to start it off with a new call called init, and here we're going to take that app object, much like we did in the controllers because we're going to handle the registration here, we're going to handle login here, we're also going to handle injection into the middleware here, we're going to handle it all in one place. So the first thing we'll do with that app object is actually implement the getting of the registration page. So we'll say app.get, register, and then a callback in the same pattern we've seen a number of times already. So when someone asks for the register, we're just going to say res.render, and the name of the view is going to be register, then we'll pass that in something with the title. We now need to use this authentication component inside of our server file. Now remember from the slides, I told you from the slides we needed to instantiate security before we call that first get. Now we haven't brought in Passport yet, but to make sure we do this right later, let's go ahead and do it before we go to the controllers where we're doing all those gets and posts handling. So first I'll get our auth object with require, and then I'll call auth.init and pass in that app object. So if we run it at this point, once we load it we can now see that there is that Register and Login that we implemented. And of course login we haven't actually written yet, but if we go to Register, we'll now see our registration form. We haven't implemented it yet, so we can just see we've built in the ability to do the registration. Let's do that next.

Implementing the Register Page

Now let's implement that register page on the server. If you remember in our register.vash, we have four different inputs here, name, email, username, and password. So here it should be fairly trivial to go ahead and say app.post, which is what the registration page is doing also to register. And because we have urlencoded middleware, our form submission is going to be part of the body object on the request. So let's go ahead and create the new user object by saying name, email, username, and then we could say password, that would work, but the problem with storing the password in the database is that it leaves it vulnerable. We don't want to store actual passwords. Instead what we want to store is a hash of the password. Now a hash is a one-way encryption algorithm so that you can take the password and run it through this little piece of encryption that gives you a magic string, and then you can run what the user gives you as a password through that same encryption method and get that final string. You can compare whether the password is correct without actually storing the password. This hash of the password is one way, we can't produce the password from the hash, we must produce the hash from the password, but by doing it the same way both from what the user challenges us what the password is and what we originally stored it as, we should be able to authenticate the user without ever storing that password. The other trick is that when you create the hash, you're going to use something called a salt, and a salt is another randomly generated string that is used to make the hash that much more difficult to break. So the hashes themselves aren't as useful without the salt and the encryption method and the original string. So in our case, we want to actually generate the hash and the salt password when we store them in the database. And we'll do that in the next video, but first let's go ahead and implement storing of this user, and then we'll come back and make the password safe to store. We're going to do this by using the data component, so let's go ahead and get the data component, and we'll use the data component to save the new user as addUser. And we'll go ahead and pass in that user and then we'll handle a callback to determine whether there is an error or not. So once we have detected an error on the callback from addUser, we'll use our tried and true method of req.flash to add in a registration error, and then error should be something the user will see, Could not save user to database. And then we'll just use the response to redirect this back to the registration page. Because we're using this flash object, we're going to need to include it in the data we're sending to the view. So if we look at the register.vash, we can see that model.message is where we can show a message to the user. So we'll just say message, go get whatever was in the flash so we can show it to the user, and they can try again. If that happens, it's probably a pretty critical error, so I'm not sure how useful telling the user, but we can kind of go from there. If it succeeds in adding the user, let's go ahead and just redirect to the login page. Now in the real world we'd probably send an email and get verification codes and all of that, but this should be the base framework you can see to implementing your own registration and login system. Of course the data component doesn't have an add user, so we need to actually add that. So let's head over to our index.js in our data component and let's add it. I'm going to go down to the, almost the end, and go data.addUser, and then this function will specify the user we want to add, and then the callback. We'll just call next. And like other components here, we're going to use getDb first, so I'm going to do some editor inheritance here to go ahead and get the database, and what are we going to do when we get the database? We're going to say db.users.insert, give it the user, and then I'm just going to use the next because if there's an error, it'll call back the callback function that was passed to us by the other component. Now, I said db.users, is this going to magically make a collection called users? It isn't in fact, we have to actually go over to the database because right now all we have is a notes collection. So if we go ahead and do the same thing, collection users, the first person to use this users collection will actually create it. So now that we've exposed that users collection, the first user inserted will end up in our database right here. So at this point, we have a working post method. We're adding the user, we're redirecting as necessary, the only problem is we have insecure passwords. In fact, we don't have any passwords or any salt. So we need to be able to secure our passwords using that encryption. And we'll do that next.

Securing Passwords

So now let's show you how to secure those passwords using a salt and one-way encryption. So we need to have a way to compute the hash, as well as generate the salt. And the way we're going to do this is to create a new file inside of our auth component, and I'm just going to call this hasher.js, you can call it whatever you want. And I'm creating it in the same folder, because the only people that care about the hashing is going to be the auth component, so we're not going to make it obvious that someone can use require to get this individually, we're just going to go ahead and create it as its own component. Now we could have created this as methods inside the auth as well, but I'd like this to be a little separate, I can go ahead and run tests against it and that sort of thing. And of course our favorite self-executing anonymous function, module.exports. And we're going to stub out two functions. We're first going to create a function called createSalt, and this is going to generate a random salt for us. There are no parameters, we're just going to generate a salt, a salt of a known length. Then we could make this fancier by specifying how long we want the salt and make it random. We're going to do it in a pretty simple fashion. Depending on your security parameters, you may want this to be a little bit more secure. And we're also going to have computeHash as a function. And this function is going to take a couple parameters. It's going to take the source string, it's going to take the salt, which it's going to use as part of that, and then it's going to return a hash based on both those pieces of information. Well let's start with the salt. To create the salt, we're first going to need a reference to a subsystem called crypto. Now crypto, notice we didn't go get crypto from the node package manger because this is something that's built into Node. The crypto library is included in every installation of Node, so we can go ahead and just require it. You can think of this as the built-in .NET framework for Node, so this is the crypto section of their internal APIs. So we're going to start by specifying a length that we want the salt, and I like eight as a decent length, but again, we're basically generating a random string, but we're going to use the crypto library to do it. We're going to do this by telling the crypto library to generate random bytes. So we're going to take the length and divide by 2 so that we're going to get a 2 character representation of bytes. So because we want the length to be 8, we need this to be 4 bytes, because 4 bytes in hexadecimal, which we're going to use next, is going to give us a string of 8 in length, and then at the end we'll just use substring to make sure that it's always going to be that magic length of 8. So this salt is something we're going to use when we create the user so that we know that each user has its own specific salt value. So back here when we store this, in the auth component let's go ahead and bring in our hasher. We'll be able to generate a salt here by calling hasher.createSalt. And this is just going to again, give us a random 8 character string. And we can go ahead and store it here. Back in the hasher, we now need to actually compute a hash, because what we want to do in our component here is say hasher req.body.password. So this is the original password that we want to hash, and then we're going to include the salt that we're going to end up storing with the user. And again, remember the idea here is that when we authenticate this user, they're going to give us a password that they were using. We're going to use that password that they hand to us with this salt to create a hash and compare against the one we're storing in the database. That way we know it's the right password without ever storing it. To get the hash, we're going to get an hmac, which is an encryption algorithm from the crypto library, and we're going to call createHmac and sha1 is an encryption algorithm. You could use one of a handful that are in there, I'm going to use sha1 because it's quick and efficient, it's not terribly secure, so you may want to go to one of the other algorithms if you have a higher security threshold like you're doing a banking app. And then we're going to pass in the salt so that the encryption algorithm has this piece that makes it a little bit more random. And then we'll create the hash itself by calling hmac.update, and giving it the source. This will generate a hash, which is a magic number that represents that source. We can then go to the hash and say give us a digest as a hex number. And this will be the actual hash we store in the database. If we've done everything correctly, let's go ahead and run this, let's go ahead and add me, you can tell I've run this a few times, and now that I have all the information, let's click Register and it takes us to that login page, because it succeeded in storing it in the database, right? Let's prove this by going to our Mongo database under theBoard/users because that's the name of the collection we created. And we can now see in the database is my user, name Shawn, email, username, passwordHash is this much more complicated version of my password, and then the salt that's being used to test the encryption. So we successfully registered a user. Let's next talk about Passport and bringing it in so we can start to validate users.

Installing Passport

Now that we have the register page done and saving of new users, let's talk about installing Passport so we can accomplish authentication. If you go to passportjs.org, you'll find the website for Passport. This is a simple set of authentication middleware for Node.js. If we look at the guide before we go ahead and install it, we'll see that it has a number of providers and includes a way to do basic and digest authentication for APIs, OAuth, OAuth 2, et cetera. We're going to be using username and password authentication for our website, but we could easily plug in other providers like Facebook, Twitter, Google, and in fact if we look at Other, we'll see that there's a number of protocols out here. So it should be able to cover most of the kinds of authentication schemes that you want to support. If we look at username and password, we'll see that it actually uses a module called passport-local to do username and password authentication against some local datastore that contains users, and that's actually where we're at. We've already saved some users to our database, we've already stored the hashes and salts for those users, so you should be able to go ahead and use Passport and passport-local to do our simple username and password authentication. Let's do that. Here we are back in Visual Studio, and I'm going to go ahead and open up a command prompt and use npm to install Passport. And I'll use that save as usual. Passport is just the framework, we're going to need to include the package for the type of authentication or types of authentication that we want included. We're going to use that passport-local because we're going to simply use username and password for our simple example. We can go ahead and close that. We can now see that passport and passport-local are installed, but they're separate packages. We're going to be using both of them. Now that we have Passport installed into our project, we're going to need to write a function that's going to do the verification, and we'll do that in the next video.

Verifying Credentials

So next we're going to write the function that's going to verify our credentials. This is going to be a function that is going to be responsible for figuring out how you want to verify your credentials, and in our case those are going to be local credentials that we've already stored in the database from our registration page. Back in Visual Studio, we're going to start by requiring passport itself. Next we need to get that local strategy, so I'm going to call it the local strategy, and I'm going to get it by requiring that passport-local, but passport-local, the object it returns, the only part of it we need is actually the strategy object. And we're going to use the strategy object when we implement our verification function. To handle verification, we're just going to create a local function, which we'll call userVerify for lack of a better name. And it's going to take three pieces of information, the username, the password, and next so we know to call the next function in our function chain when we're done, either with a success or a failure. Inside the user verify we're going to use that data component to get a user based on their username. We're going to get the user and then we're going to verify the password, but let's start with getUser. We're going to pass in the username and we're going to then pass in a callback function that's going to either return an error or the actual user we're looking for. Before we can finish implementing this, let's go create that getUser method, which doesn't exist on our data component yet. So down here I'll just say getUser, username, next. Next is that callback that will callback with either success or failure, and we'll start with this little piece of code to get us the database itself, and if there is an error, we'll just call next with the err. We'll return back to the caller essentially the err object. Otherwise, we want to use this db object. We want to go to the users, remember just like we inserted users here, we're going to instead of insert call findOne, and then give it one of these query objects. In our case that will be username, and the username that was passed in. And then for the second parameter I'm just going to pass in the next because it follows the same pattern, err is the first argument, the user itself as the second argument, so we'll get back what we actually want. So we want to be able to check to see that the user is verified, but let's go ahead and write the failure first, which is going to be next, and the passport system expects a different callback mechanism, it actually wants null for the first parameter and then false if it's a failure, and then a message that contains what the failure was. And because we don't want to tell them what kind of failure, in all cases when this fails we're just going to say Invalid Credentials. We're not going to say that we failed to find a user with that username, we're not going to tell them it was a bad password or something like that, we're simply going to say hey, it didn't work. So this is going to be the fall through. So here we can say if not err and if user, so if we have a user and there wasn't an error, then we have a good user object to test against. So the first thing we're going to want to do is get the hash of the password that was sent in. So let's call that the test hash. And we'll do this by calling the hasher.computeHash just like we did earlier, and we're going to pass in the password because that's the phrase we want to hash, and then we're going to pass in the user.salt, so we're going to get that special randomness for this specific user. And here now that we have a hash of the candidate password, we're just going to test that the testHash is the same as the user.passwordHash. And if it succeeded, we're then going to call next with a null as the first parameter again, but in this case we're going to give it that user object. And we're going to break out of this by just saying return. So at this point we have a function that does the verification, we're going and getting a user from the database, we're testing to see whether we got a valid user based on that username, so one existed. And if it did exist, we're going to hash the current password in the same way we originally did, and then we test to see whether the hashes match. If they do, they're correctly logged in and we're going to tell the passport system this is successful and in fact this is the object that represents the user, and that's the data we're getting from the database. Now we're ready to go ahead and implement Passport now that we have the verification function and we brought in Passport in the strategy. Let's do that next.

Integrating Passport.js and Express.js

And finally we're ready to bring it all together. We're going to bring Passport and Express together and tie it in as the authentication middleware for Express. In order to do this, we're going to start inside of the init and we're going to set up passport authentication. The first thing we need to do is take that passport object we have and we need to tell it what kind of authentication to use, and in our case that's going to be a new instance of the localStrategy. And as a parameter, the new local strategy takes the userVerify function, the function we created in the last video, this one up here. So we're saying use username and password and when you verify username and password, use this function. We could also passport.use for a number of other strategies if we were also going to support Google and Twitter and other OAuth implementations, but for us we're just going to use localStrategy. The next thing we need to do is that Passport needs to know how to read and write a user, this is something we have to tell it to do. So passport.serializeUser, and this serializeUser takes a function that passes us the user it wants to serialize, and then what to do next. And for us, serializeUser is I want to store, this is an interesting user, so that later I can ask you to go look up the user. I'm essentially asking you for a key of the user. So we can simply say next and we're going to pass a null and then the user.username. So we're telling it there isn't an error, and then this is what we want to use as our key. We're also going to need to implement a deserializeUser, which also takes a callback function. In this case it's going to pass you the key and then what to do next. And what we're going to do is use the key to get the user and return the new user object. So we'll call the data component getUser, pass in the key, which in this case is going to be the username because it was used here, and if there was an error, we'll call next saying error, passing in null, and then false to tell it's an error, and then an object that includes a message, Failed to retrieve user. And if we did find the user, we're going to call next, null because there is no problem, and then the user itself. Once we do this, we can finish the setup by simply calling app.use and use this passport object that we've now added the local strategy to in the serialize and deserialize to and just call initialize. And this will return an object that represents the entire middleware for Passport including all these individual configuration pieces we've put together. We'll also want to call passport.session to tell passport to use session to store the login users temporarily. Now there's some other options here you can see in the docs. We're going to use session because that's nice and simple and we've already included session as something we're going to use as part of our project. Now that we've done this, we can go ahead and implement the login page, which is what we'll do next.

Creating a Login Page

Now that we've gone through all the trouble of creating the registration page and integrating Passport, let's go ahead and use login so we can actually see this in action. I'm going to start by bringing in a Vash view from the resources folder. This is an existing view called login.vash. If you have access to the source code through a Pluralsight Plus subscription, you can go ahead and just grab it from the resources folder in this module's examples. If you don't, it's a really simple form. It's a simple Vash form that simply has two pieces of information, an input for username and an input for password. I also have a Submit button to make it all work, and then I'm posting to /login. So if you need to recreate this yourself, it's pretty straightforward. There's also a place for a message in case there is an error of some sort. If we go back to the index for authentication, we can go ahead and add the login by just doing app.get, login, req, res, just like any other view. And this is to show the view, this isn't to accept the credentials, this is just to show the view. We can get this by saying render, login, and like the others we'll use a title. And to preempt this, I'm going to include the flash message for this because we will want to be able to show an error if necessary. And we'll call this our loginError. We will need to do the post to login as well. And we need a callback function that's going to take the req, the res, and an additional parameter called next. The reason for next is that we're going to pass back after the post whether the login has been successful or not. So this is particular to the way Passport works. In order to do the authentication we have to actually create an auth function by calling passport. That's the reason we're doing this work inside of the auth components is we have access to the passport object and we want to be able to reuse that. So we're going to call passport.authenticate and we're going to pass in the kind of authentication we want. In our case we only have one, but we may have multiples, and so it requires us to tell it what kind of authentication it wants us to perform. In this case it'll be a local authentication or username and password, which is another name for local. After that, we're going to include a callback that's going to give us the error, the user, and some info if we need it. So this auth function is just getting Passport to give us a function that we can then call with some context. So here we're going to call that auth function by passing in the request, the response, and that next object. This is where the actual authentication happens. This is just putting together an object that can be called for that authentication. And finally in here in this callback we're going to be told whether it succeeded or not because of the callback. So if err, we're just going to call that next function with our err. So we can tell it, oh something bad happened, move on. Otherwise we're going to use that request object and all login, log capital I-n. And here we're going to give it that user object and then a callback with any possible error we may have. In here we'll need another nested check if err. We're also going to say hey, something bad happened. Otherwise, we're actually going to use the response and redirect to some directory. So in our case we want to go back to the home page once the login has been successfully done, though you could imagine using the querystring to look at what is the exact URL you really want to go to. I'm not going to go to that depth with our example here, but at this point we should be able to successfully login through this post, and when the post succeeds, this should cause a redirection back to our home page. Let's go back in our views and look at layout and use some of this so we can actually see it work. So one of the things we can do here is just create a little div and we'll just use the model.user.name to show the current user if they're logged in. And so we'll probably want to check this like if model.user. If it exists, we'll show this, otherwise we'll just skip it, and that's pretty standard, Vash or razor-like syntax to do that. The problem is how do we get this model user in there? So in our case we can go ahead and open up the controllers and let's go to that homeController, and for our home page, let's go ahead and add the user here if it exists, req.user. Now this is interesting. The request, any request that happens here, the Passport middleware is taken care of. So this req.user doesn't really exist in most cases, especially if we're not using Passport. And so the Passport middleware is saying hey, someone has logged in, this is the right person that's logged in, and now that I've deserialized it back into a user, I can now put that user in the request object on each request so that every page has access to this. And all we're doing is adding it to the model so we can then use it on our markup. And in the same way, we should actually add this to most pages. So let's come down here and add it to most of our pages. Now of course if you're not logged in, req.user is going to be undefined and so our user will be undefined and everything will work, because that'll become the test for whether someone is actually logged in from our markup page. So let's run this and login so we can actually see this work. So here we have our website, and you remember we had created that Login button earlier, but we know we're not logged in because the name isn't showing up here. So let's go ahead and login. And if I go ahead and use that user I used earlier, see it brought us back to the home page and now it's showing us the currently logged in user. So the user object we can actually use in the way we want it to. So now we have a login correctly implemented. Let's talk about protecting the API and protecting pages with Passport next.

Authorizing Pages and APIs

The last piece of this puzzle is that we are going to authorize pages in APIs having mechanism for dealing with login. Back here in Visual Studio, we have the auth object here and we've augmented it with an init that we've called from the main JavaScript file, but we also want to add a couple of other functions that will be helpful in protecting APIs and pages. Let's start with pages by implementing a function called ensureAuthenticated. And this function, it'll take the req, the res, and then what to do next. This is a common pattern you'll see quite a bit. So inside this method we want to see if we've been authenticated, and we can do that by looking at the request and calling a function called isAuthenticated. Now it is a function, so remember to pass in the empty parens, because it's going to evaluate this. Now this is a function that's added to the request object from the Passport middleware. So this'll be able to tell whether we're actually logged in or not so that we can make a decision here about what to do. What we're going to do if we're authenticated is actually just call that next function. We're essentially saying hey, if we're authenticated, let the page operation continue. And if we're not, let's go ahead and use the response and end the response by saying redirect to the login page. Now we could certainly have done a question mark final, or some querystring parameter to tell it where to go after the login, but we're not going to be fancy yet, we're going to show you how this is working. Now that we have this as part of the auth object, let's see how it's used. So over in the homeController, we're going to first need auth component because we're going to use it to protect our individual page. So let's come down here to notes and this notes page, let's say we want to protect it to only logged in users. What we can do is use this function ensureAuthenticated, and I'll just nest this below. I like using this one line per so we can really see what's happening. We're giving it the function, we're not calling the function, we're giving it the function, and what we're essentially telling the get to do is call this first function and if it succeeds, if its next is called, then go ahead and call what, the next function. If this doesn't, if this ends the request, which we're doing by redirecting, this function never gets called, therefore, that page never gets rendered. So what does this look like when we run it? So we're here in The Board. We're not logged in because we know that because the username isn't here. And let's go to one of the pages. It took us to the login because we weren't logged in. Let's login really quick, we're logged in because of Shawn Wildermuth, and now if we go to the notes page, it knows that and is allowing it to succeed. That's a very simple pattern to go ahead and protect your individual pages or your routes for whether they're authenticated or not. Let's do the same thing with an API. So in the case of an API we need another function, and you don't have to have them quite this long, I've just gotten into the pattern, so ensure API is authenticated. And in this case it's the same pattern. In fact it's the same thing that's happening. The difference is, and I'll use some editor inheritance here to make it be a little quicker, is that if it's authenticated we still want to do next, we're going to the same sort of operation, but in this case if it isn't allowed, what are we going to do? We're going to send 401 Not authorized, or whatever we want to put as an error message here. We're sending the result as something in the API users can actually use. So let's come over here to our notesController where we have some of our API calls and let's do the same thing. We're going to bring in auth as a require. Now that we have the authentication controller, we can do the same thing we did before, but use the new function to protect it. And we'll go ahead and repeat this for the post just to be nice and safe. I'm not actually going to show you this part working, but it's good form to do the right thing. So the idea here is we could use the authenticated, but of course what will be returned to the API is a string that contains the redirection. So instead of that we're going to return a 401 so that the users of our API can actually do something about it. If we go over to Fiddler, we can execute that history call and we'll see here it is a 401. So not only is it going to give us the Not authorized as the body of the message, it's going to say 401, which is unauthorized. So we're doing the correct thing and telling the API something that they can actually test against, oh we're trying to use the API, we're not authorized, therefore we need to be able to login beforehand. So in this way, we can protect both pages and APIs using this Passport middleware and all is good. Let's wrap up this module.

Summary

So in this module, we've learned about securing Node.js. This started out with explanation that Express apps are using middleware to create a pipeline, and this pipeline is simply a set of chained functions. So the different middleware can interrogate the request and the response before it gets down to our individual page or API calls. I've shown you that Passport is the security middleware that handles a variety of different ways of authenticating your users, whether you want to use username or password, whether you want to use OAuth implementations like Google, Microsoft Account, Twitter, et cetera, that Passport can handle all of them. We've seen how to build our own registration page and how to store those in the database building on information we learned in the prior module where we talked about storing data in the database. I've shown you a way, a fairly simple way, to not store passwords in the database. In fact, a way to store a one-way hash so that you don't have to actually store them, which can be a security hole. I showed you how to take Passport and plug it into Express by implementing verification and serialization methods so that you can use your own storage mechanism, but be able to tell Passport what a user is, what a user Id is, and how to actually verify that a user is authenticated. Once we plugged Passport in, we were able to add a login page and be able to store that data, and in fact show that we were logged in and who we were logged in as in a pretty simple way. And finally, I showed you how to use that authentication to protect certain pages so that a user would have to be logged in in order to have access to that page. What we're building are pretty simple pieces and components. What we built in 3 or 4 lines, you could certainly augment to create more sophisticated authorization schemes on top of the authentication scheme that Passport provided us. This has been the Securing Node.js module. My name is Shawn Wildermuth of Wilder Minds. Thanks.

Real-time Communication with Node.js

Introduction

In the next module, we're going to be talking about real-time networking with Node.js. In this module, we'll start out by explaining what is a WebSocket. We'll then dive into Socket.IO, and then we'll actually show you how it works, we'll introduce Socket.IO to our project, we'll write the client-side of Socket.IO, we'll talk about broadcasting with Socket.IO, and finally show you how rooms work with Socket.IO. Let's get started.

What are WebSockets?

I want to start this module by talking about a standard that is fairly new called WebSocket. WebSocket is the ability to do full-duplex communication over TCP for web browsers and servers. And the idea behind this is to allow web pages to do socket-like communication where you need something like real-time communication between an individual browser and the client. WebSocket is bidirectional by nature, so you're able to send stuff to the server and the server is able to send things directly to you. This is counter to the typical idea about how HTTP works, which is connection list by default. WebSocket is not connection list, it's not trying to pretend to be HTTP and doing something special like some other technologies like Comet has done. It creates a persistent tunnel between the browser and the server and keeps that tunnel open like you would expect in typical socket implementations. WebSocket is also proxy and firewall friendly, it does most of its communication over port 80 and certainly does the handshake over port 80 so that you don't have to deal with typical firewall issues, and it also is aware of proxy servers and is able to get around them with its particular implementations on individual browsers. WebSocket is also a web standard, which means that most modern browsers have implemented it. This includes Chrome, Firefox, Safari, and IE. Only recent versions of those different browsers actually have implemented WebSocket, so depending on the nature of your client, you may or may not be able to use WebSockets. WebSocket is simply a way to solve the problem of bidirectional communication on the web. This is something we've all wanted and then we've sort of mimicked by having rich clients, having polling systems that pole the server for communications because at its core, the web is based on this idea of connection lists, I make a request and you send me back a response. It's important to understand if you're going to use WebSockets themselves, it's going to depend on modern browsers. It relies on HTTP for the handshake of the connection only, and the rest of the communication is done over its own set of protocols. The suggestion is instead of writing raw WebSocket code, that you would rely on libraries to simplify the implementation of WebSocket. Now this doesn't mean you can't go down and do WebSocket code, but it does mean that it may be easier to use some other abstraction layer over WebSocket. And that's what we'll talk about next.

What is Socket.io?

Socket.IO is a set of JavaScript technologies, one for Node.js and one for the browser that abstracts this bidirectional communication with the browser. Now the reason for this abstraction isn't just to simplify WebSocket code, but to also handle browsers that aren't yet fully implemented with WebSockets. Socket.IO has a downgrade mentality so that it will work with other browsers as well as it can. So for instance, if you're working on IE 5 or 6, but you happen to have Flash installed, Socket.IO will actually drop down and use Flash in those cases instead of WebSockets because WebSockets don't actually exist on those older browsers. The idea of an abstraction layer over these different transports means that you can write the code once and be worried less about what browsers it's going against. And if you're coming from ASP.NET, there is a corollary here, and that is SignalR. If you worked with SignalR, a lot of the same ideas exist in Socket.IO. Simply put, Socket.IO is about simplifying creating these single cast and multicast scenarios in your applications. There are two libraries, a server library and a client library, and they do have to work together. Socket.IO doesn't rely on Express, but it will work side by side with Express or other libraries like it. It can integrate with the code you're working with Express, if you followed along in our course, you'll see that we'll be able to plug the Socket.IO implementation in side by side with the data access and the controllers and the security that we're working with in our existing application. On the client-side, Socket.IO works plenty well with most client-side libraries, including AngularJS, so we'll show you that as well. So let's build something so you can see how Socket.IO can change the way you think about bidirectional communication in web projects.

Starting with Socket.io

So let's start out by bringing Socket.IO into our Node.js implementation. Here in Visual Studio I'm just going to open up a command prompt, and this is another library you can install via npm. It's just called socket.io, and I'll do the ---save again as I've done with most of our other libraries. You will notice on Windows it's attempting to build some pieces, but it has a fallback strategy, so this red part of npm working is just a warning. So we now have Socket.IO installed on our project, and what I'd like to show you is the ability that as people add notes for those same pages to be able to show the new notes without us having to constantly badger the server about it. So we're going to create a new component here by starting with a folder, calling updater. And this will be an implementation of Socket.IO that allows us to see updated data across browsers. So if we go to the JavaScript file here, and as usual I will call index.js and I'll start us with an saf. Next we'll create a method called init, and this is going to take a server object. Now the server object is something that we're creating in the server.js, in that main JavaScript file. Here at the end we're creating the server and then we're listening for it. And in fact we'll go ahead and require our updater, let's say updater.init, and pass in that server object, because that server object is something that Socket.IO is going to attach to to also listen for its messages. So this server.listen is telling it to listen as a web server, and then inside of here, we will go ahead and use that server object to listen for Socket.IO messages. Outside the updater, let's go ahead and get our library, and then we can start to listen. And we do that by creating an object, which I'm just going to call the io object, because by convention it's typically been called io, and I'm going to do it by calling socketio.listen and passing in that server. This is where we're instantiating that we're actually listening on the socket for clients to start sending us messages. Now that we have the io object, we can use its sockets member to listen for messages, and we do that with an on call. So on, we're going to first look for connection, and this is typically the first message you look for, and then we'll have a callback that gives us the socket that connected with us. And this is important because we may be connected to a lot of different clients, but a connection will happen for each of those clients, and so we end up doing a lot of work with this socket object inside of this callback, and in this way we have a single socket and all of its associated objects related to a single client that we're connected to. Once we do the connection, let's go ahead and write out to the console so we can see that a socket was connected, so we can see that this actually did happen. Now that we're listening for a socket, we can go ahead and wire up the other side, which is the client-side of it, and we'll do that in the next video.

Client-side Socket.io

So next, let's build the client-side of Socket.IO. The first thing we're going to need is we're going to need those client components. So I'm going to go back out to the command shell and use Bower to install socket.io-client. Now you may make the mistake a couple of times of actually installing Socket.IO with Bower, and this will actually install the server bits inside the client directory, so don't do that, make sure you do --client because that's the full name of the package, socket.io-client. There we've got it, and now let's go ahead and open up our notes view, because this is where we want to actually use it. And we have this scripts block where we were pulling in our notes view. So let's go ahead and look at our public folder under lib, under socket.io-client, and under dist, and we'll find socket.io.min. And I'm just going to drag it into that same folder and like all of the public pieces, I'm going to need to get rid of that beginning and start it with lib and then the path to our script, and not just bringing it into the page like we would in typical web development. Now that we have it, let's go ahead and open up our client-side JavaScript, this is where we were using Angular in the earlier module, and down here after we have handled the HTTP get, let's go ahead and use this. We don't have to include or do a require here because it's already on the page, what we can do is create the socket that we want to talk to on the server, and we can do that by calling io, which is the object that the client-side library exposes, and say connect. Now this connect could also take a server path, or an URL, but in our case, we're not including one because we know it's the same server that our web page was serviced on. So let's go ahead and run this. When we come into our website, we'll need to quickly login, because remember the notes page is not available if we're not logged in, and so let's go to that History page. So we got to the History page, we haven't really done anything with Socket.IO, but if we tab over to the console, we can see socket was connected. In fact, every time we refresh this page, we're going to get another socket was connected. Now this is some info and debug information because we're using a debug version of the logger, and so Socket.IO is spitting out some information that's useful for us. So we're actually connecting to the page, but let's do something interesting with it. Over on the server after we connect, let's go ahead and just use the socket and emit to that socket a message. And I'll just call the message showThis, and this is just some key to know what the name of the message is, and then some information like this is from the server, for example. And this emit is going to send it to this individual client. So on the client-side, we can then take our socket and say on, showThis, again that same message name, and then get a function callback for when it happens. Notice that the on pattern is the same for both, right, the socket.on for the client listening and socket.on for the server listening to the same thing. And I'll just show the message in an alert if it comes in. So let's refresh, it's going to force us to re-log in, and we got the message. So we connected to the server and the server immediately took that socket information and then sent us a quick message. So we can see that we're getting that communication on both sides. Node.js could pretty simply use this to send individual messages to individual browser windows, but that's not really where it's most interesting as far as I'm concerned. What we'd like to do is every time we add a new note here, I would like to see this note show up for everyone who happens to be looking at History, I want to be able to broadcast that. So let's do that next in our next video.

Broadcasting Messages

So next, let's use Socket.IO to broadcast to all the clients that are connected. So on the server, let's get rid of this emit for showThis because that's just sort of a dumb thing to do. Instead, let's listen for a message from the client. In this case I'll say socket.on, and I'll call this newNote and when someone calls us with a newNote, we'll expect some data, and this data doesn't need to be a string, we'll see that in a moment, and when we get this new notification from a client, let's go ahead and say socket.broadcast.emit. So the emit is the same pattern here, name and value that you're sending to it, but because we're using the broadcast member of socket, we're telling it to broadcast to all members. And in fact because we're on a socket call, it knows to only broadcast it to everybody but the person whose socket we're already on. And so you don't need to start figuring out that you're on the same socket that sent the message or any of that sort of headachy stuff. And I'll just call this broadcast note. And here I'll send down the data that happens to be the note that was sent to us. Data is going to include more information, but we're just going to send it back the actual note, we're going to send this to all clients that we got a new note. Over on the client-side, let's do the same as getting rid of this. Instead we're going to actually listen on broadcast note, which was the name we were passed as the message name from the server, and when broadcast note happens, what are we going to do? Let's go ahead and push this new note into our note collection. We're inside of an AngularJS controller, so we can just use the scope.notes.push and add our new note, and we'll use scope.apply to force the data binding to update. Normally inside of AngularJS it would know about the change in the push, but because we're in a non-Angular piece of code, it doesn't know it's happening, so this will force the data binding to show the new piece of data. So we've got the listening part, what about the sending part? Let's come down here to where we're actually receiving the newNote from the server, and let's go ahead and use our socket.emit, newNote, and what we're going to send are two pieces of information. We're going to send the categoryName and then we're going to send the actual note, which is result.data. So we're sending structural data here back up to the server, and then it's pushing back to us just this new note. So let's see if this works. So now we have the website opened up in two different browsers. Here is IE on the left and Firefox on the right. And if I go to the History tab, we'll go ahead and log in, we can see Shawn Wildermuth there. We'll do the same thing here, History tab. Let's go to History on both pages. And IE doesn't like my font, but we can ignore that for now, it's good enough. So let's come down here and let's go ahead and add a new note. Let's add a green note that says History is awesome, and save it. It got added here, but guess what, it got added here as well. Because when we sent the message out to the server, it then broadcasts it to everyone who had connected to it. So if we keep this down a little further and we'll add a new one, we'll make this one blue, we can see it's close into real-time as we can that that new item is added. Now this would be awesome, you're probably going cool, right? We have one little problem. So let's go to the Gaming tab, and remember I'm on the History tab here, here's my content, and I'll add History isn't for gaming, and save it. Uh oh, we added it to the Gaming tab. The problem we have is in our code right now. Let's go back to it. When we send the node up or emit it, we're including the categoryName, but we're not filtering by the categoryName. And certainly we could in here check to see if the category was us, but of course that means we would be broadcasting to every single page, and we might have hundreds of categories, so we're doing all this broadcasting and having the client filter it out, and that doesn't make a lot of sense. Over here on the server, we could build up a manual list of sockets that are all on particular pages because remember that when we get this note, we have the category here, we could do the filtering. But that's a lot of work as well. Luckily Socket.IO includes something called rooms where you can sort of put people into these named containers, and those named containers can then be broadcast to. Let's show you how that works in the next video.

Using Rooms

So let's next use rooms to make broadcasting to individual audiences easier with Socket.IO. So over on the server, let's wait for another message, and we'll just call it join category and it'll take a category name. And what we'll use this for, and I'll implement this in a second is that over here when we connect to our socket, we're going to immediately send to the server some more information. We're going to say join category and give it our categoryName that we already have on our page. We're going to tell it that we're part of this category. We can simply use a method called socket.join that's going to take some key, and in our case that's going to be the category. We're going to create a room based on those category names. And that way we can say, instead of broadcasting to everyone, we're going to broadcast.to, and we're going to give it a name, data.category, which is going to be the category name that this new note belongs to. So let's talk about what's happening here. When we join the category, we're telling it this socket belongs in this particular room, and a socket can belong to more than one room, and then when we get a new note, we're only going to broadcast it to people in that room so that only people on the History page will get History notes. And so we're limiting how much of that broadcast of that multicasting we're going to do to only the clients that really care about it. So we don't have to do some weird client code to get around the fact that we're broadcasting to everybody, we're not broadcasting everybody, we're only going to broadcast to the people that matter. So let's see that work. Now that we're logged in in both places, if I go to History, and let's scroll down in both, let's put a This is fun in green and save, we're going to get our new field whether we like it or not, right, but if we change this to go back to let's say Gaming and put another one in, you'll see that it doesn't show up in the other category, it's only going to show up and be announced to the category that each individual browser is working on. One thing you'll notice is that when the socket disconnected, that we didn't have to do any work. Socket.IO is really good at disconnecting the clients that aren't listening anymore, or that don't matter. You can handle the disconnect message, but don't do it just to clean up the Socket.IO work. If you actually need to do some work on disconnect and cleanup of your own code, that's fine, but don't think that you have to manage the lifetime of each of these socket objects for the individual client, it actually does a really good job of maintaining that. And that's how rooms work. And so if you put together the connection, you put together emitting messages on both sides, both on the server and the client, you put together using broadcasting and then finally broadcasting to individual rooms, you have a pretty rich ecosystem in very few lines of code for doing real-time communication back and forth. This bidirectional nature of the way that Socket.IO works means that you can write pretty sophisticated applications without having to deal with really complex code. Let's wrap up this module.

Summary

So what have you learned in this module? We've seen that there's a standard called WebSocket that gives you a non-hacky way of doing bidirectional communication. We've also shown you Socket.IO as an alternative to using WebSockets natively so that you have something that will work with different and other browsers and also has a very simple interface for dealing with it. You also learned that Socket.IO uses WebSockets whenever available, but will drop down into other solutions for older browsers or mobile browsers that may not have implemented WebSockets. I've shown you how to build both the client and the server part of Socket.IO so you can communicate between client and server pretty easily, you've seen how to broadcast messages to all clients with Socket.IO, and then to also broadcast to a subset of those connected pages using rooms and in Socket.IO. This has been Real-Time Networking with Node.js. My name is Shawn Wildermuth of Wilder Minds. Thanks for joining me.